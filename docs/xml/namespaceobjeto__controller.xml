<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="es">
  <compounddef id="namespaceobjeto__controller" kind="namespace" language="Python">
    <compoundname>objeto_controller</compoundname>
    <sectiondef kind="var">
      <memberdef kind="variable" id="namespaceobjeto__controller_1a032a188678b092efd0b10de226f78836" prot="public" static="no" mutable="no">
        <type></type>
        <definition>objeto_controller.router</definition>
        <argsstring></argsstring>
        <name>router</name>
        <qualifiedname>objeto_controller.router</qualifiedname>
        <initializer>=  <ref refid="classfastapi_1_1routing_1_1_a_p_i_router" kindref="compound">APIRouter</ref>(prefix=&quot;/objeto&quot;, tags=[&quot;Gestión de objeto inteligente&quot;])</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/app/api/objeto_controller.py" line="32" column="1" bodyfile="micro_gestion_objetos/app/api/objeto_controller.py" bodystart="32" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespaceobjeto__controller_1af05241f784ab7fa3a30deecc788c1b74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>objeto_controller.get_identificator</definition>
        <argsstring>(str osid=Query(..., description=&quot;ID del objeto inteligente&quot;), ObjetoService objeto_service=Depends(get_objeto_service))</argsstring>
        <name>get_identificator</name>
        <qualifiedname>objeto_controller.get_identificator</qualifiedname>
        <param>
          <type>str</type>
          <declname>osid</declname>
          <defval>Query(..., description=&quot;ID del objeto inteligente&quot;)</defval>
        </param>
        <param>
          <type>ObjetoService</type>
          <declname>objeto_service</declname>
          <defval>Depends(get_objeto_service)</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>    @brief Obtiene los metadatos del objeto inteligente.
    
    @param osid Identificador único del objeto inteligente (OSID).
    @param objeto_service Instancia del servicio de objetos (inyectada por dependencia).
    
    @return JSONResponse con status 200 y metadatos del objeto si es exitoso,
            o error 400/500 si falla.
    
    @exception ValueError Si el osid no es válido.
    @exception RuntimeError Si hay error en la persistencia.
    
    @details
    Flujo:
    1. Valida que el osid coincida con el objeto inteligente activo
    2. Verifica que existan metadatos en persistencia
    3. Retorna los metadatos en formato JSON
    4. Registra logs y eventos en el panel MQTT
    
    @see ObjetoService.getIdentificator()
    
    @example
    GET /objeto/Identificator?osid=obj_001
    200 OK
    {
        &quot;status&quot;: &quot;success&quot;,
        &quot;message&quot;: &quot;Metadatos del objeto inteligente obtenidos correctamente.&quot;,
        &quot;data&quot;: {&quot;id&quot;: &quot;obj_001&quot;, &quot;title&quot;: &quot;Sensor Temperatura&quot;, ...}
    }
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/app/api/objeto_controller.py" line="36" column="1" bodyfile="micro_gestion_objetos/app/api/objeto_controller.py" bodystart="36" bodyend="75"/>
      </memberdef>
      <memberdef kind="function" id="namespaceobjeto__controller_1ae5f1ef3cecaa7f2b0ee40d30bbeed98b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>objeto_controller.start_object</definition>
        <argsstring>(ObjectData data, ObjetoService objeto_service=Depends(get_objeto_service))</argsstring>
        <name>start_object</name>
        <qualifiedname>objeto_controller.start_object</qualifiedname>
        <param>
          <type>ObjectData</type>
          <declname>data</declname>
        </param>
        <param>
          <type>ObjetoService</type>
          <declname>objeto_service</declname>
          <defval>Depends(get_objeto_service)</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>    @brief Inicia un nuevo objeto inteligente con datos proporcionados.
    
    @param data DTO ObjectData con configuración del objeto (feed, datastreams, etc.)
    @param objeto_service Servicio de objetos (inyectado).
    
    @return JSONResponse con status 200 si es exitoso, o error 400/500.
    
    @exception ValueError Si los datos del DTO son inválidos.
    @exception RuntimeError Si falla poblar ontología o persistencia.
    
    @details
    Operación compuesta que:
    1. Verifica que la ontología no esté ya activa
    2. Estructura los datos del objeto inteligente
    3. Puebla la ontología (crea individuos y relaciones OWL)
    4. Persiste metadatos en JSON/DB
    5. Crea dispositivo en ThingsBoard (IoT Platform)
    6. Registra datastreams en microservicio_data_stream
    7. Registra evento en panel MQTT
    
    @note Esta es una operación distribuida que requiere coordinación entre
          múltiples microservicios. Considerar implementar saga/compensación.
    
    @see ObjetoService.startObject()
    @see docs/diagrams/flow_diagrams.md (StartObject sequence diagram)
    
    @example
    POST /objeto/StartObject
    Content-Type: application/json
    {
        &quot;feed&quot;: {
            &quot;id&quot;: &quot;obj_sensor_001&quot;,
            &quot;title&quot;: &quot;Sensor Temperatura Sala&quot;,
            &quot;description&quot;: &quot;Sensor DHT22 en sala A&quot;,
            &quot;datastreams&quot;: [&quot;temp&quot;, &quot;humidity&quot;]
        }
    }
    
    200 OK
    {
        &quot;status&quot;: &quot;success&quot;,
        &quot;message&quot;: &quot;Objeto inteligente iniciado con éxito.&quot;,
        &quot;data&quot;: {}
    }
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/app/api/objeto_controller.py" line="76" column="1" bodyfile="micro_gestion_objetos/app/api/objeto_controller.py" bodystart="76" bodyend="131"/>
      </memberdef>
      <memberdef kind="function" id="namespaceobjeto__controller_1a29e614f29e33f15dcc3f43278440926a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>objeto_controller.get_state</definition>
        <argsstring>(str osid=Query(..., description=&quot;ID del objeto inteligente&quot;), ObjetoService objeto_service=Depends(get_objeto_service))</argsstring>
        <name>get_state</name>
        <qualifiedname>objeto_controller.get_state</qualifiedname>
        <param>
          <type>str</type>
          <declname>osid</declname>
          <defval>Query(..., description=&quot;ID del objeto inteligente&quot;)</defval>
        </param>
        <param>
          <type>ObjetoService</type>
          <declname>objeto_service</declname>
          <defval>Depends(get_objeto_service)</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>    @brief Obtiene el estado actual de los datastreams del objeto inteligente.
    
    @param osid Identificador único del objeto inteligente.
    @param objeto_service Servicio de objetos.
    
    @return JSONResponse con status 200 y estado de datastreams (valores, tipos, timestamps).
    
    @exception ValueError Si osid es inválido.
    @exception RuntimeError Si falla la consulta al microservicio datastream.
    
    @details
    Flujo:
    1. Valida que osid coincida con el objeto inteligente activo
    2. Delega consulta a microservicio_data_stream.send_state()
    3. Normaliza la respuesta (mapea campos a estructura uniforme)
    4. Opcionalmente enriquece con consultas a ontología
    5. Retorna estado normalizado
    
    @note Usa asyncio.to_thread() para no bloquear event loop si cliente HTTP es síncrono.
    
    @see ObjetoService.get_state()
    @see docs/diagrams/flow_diagrams.md (GetState sequence diagram)
    
    @example
    GET /objeto/SendState?osid=obj_001
    
    200 OK
    {
        &quot;status&quot;: &quot;success&quot;,
        &quot;osid&quot;: &quot;obj_001&quot;,
        &quot;datastreams&quot;: [
            {&quot;variableEstado&quot;: &quot;temp&quot;, &quot;type&quot;: &quot;float&quot;, &quot;valor&quot;: 23.5, &quot;dstype&quot;: &quot;sensor&quot;},
            {&quot;variableEstado&quot;: &quot;humidity&quot;, &quot;type&quot;: &quot;float&quot;, &quot;valor&quot;: 65.2, &quot;dstype&quot;: &quot;sensor&quot;}
        ],
        &quot;timestamp&quot;: &quot;2025-01-10T15:30:45Z&quot;
    }
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/app/api/objeto_controller.py" line="132" column="1" bodyfile="micro_gestion_objetos/app/api/objeto_controller.py" bodystart="132" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="namespaceobjeto__controller_1a911533e9228d9e95deaee73a861a62e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>objeto_controller.send_data</definition>
        <argsstring>(str osid=Query(..., description=&quot;ID del objeto inteligente&quot;), str variableEstado=Query(..., description=&quot;Variable del estado a enviar&quot;), str tipove=Query(&apos;1&apos;, description=&quot;Tipo de variable (1=actuador, 2=sensor, etc.)&quot;), ObjetoService objeto_service=Depends(get_objeto_service))</argsstring>
        <name>send_data</name>
        <qualifiedname>objeto_controller.send_data</qualifiedname>
        <param>
          <type>str</type>
          <declname>osid</declname>
          <defval>Query(..., description=&quot;ID del objeto inteligente&quot;)</defval>
        </param>
        <param>
          <type>str</type>
          <declname>variableEstado</declname>
          <defval>Query(..., description=&quot;Variable del estado a enviar&quot;)</defval>
        </param>
        <param>
          <type>str</type>
          <declname>tipove</declname>
          <defval>Query(&apos;1&apos;, description=&quot;Tipo de variable (1=actuador, 2=sensor, etc.)&quot;)</defval>
        </param>
        <param>
          <type>ObjetoService</type>
          <declname>objeto_service</declname>
          <defval>Depends(get_objeto_service)</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>    @brief Envía datos a un datastream específico del objeto inteligente.
    
    @param osid Identificador único del objeto inteligente.
    @param variableEstado Nombre/ID del datastream (p. ej. &apos;temp&apos;, &apos;humidity&apos;).
    @param tipove Tipo de variable: &apos;1&apos; (actuador), &apos;2&apos; (sensor), etc.
    @param objeto_service Servicio de objetos.
    
    @return JSONResponse con status 200 y resultado de envío.
    
    @exception ValueError Si osid o variableEstado son inválidos.
    @exception RuntimeError Si falla la comunicación con microservicio datastream.
    
    @details
    Flujo:
    1. Valida que osid coincida con el objeto activo
    2. Verifica que variableEstado no esté vacío
    3. Delega en dataStream_service.send_data() con asyncio.to_thread()
    4. Registra log en panel MQTT
    5. Retorna respuesta normalizada
    
    @see ObjetoService.send_data()
    @see microservicio_data_stream Para documentación de datastreams
    
    @example
    GET /objeto/SendData?osid=obj_001&amp;variableEstado=temp&amp;tipove=1
    
    200 OK
    {&quot;status&quot;: &quot;success&quot;, &quot;datastream&quot;: &quot;temp&quot;, &quot;sent&quot;: true}
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/app/api/objeto_controller.py" line="179" column="1" bodyfile="micro_gestion_objetos/app/api/objeto_controller.py" bodystart="184" bodyend="223"/>
      </memberdef>
      <memberdef kind="function" id="namespaceobjeto__controller_1acbe0a134fad4fa3bb39b5ff5ef3a01ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>objeto_controller.send_service_state</definition>
        <argsstring>(str osid=Query(..., description=&quot;ID del objeto inteligente&quot;), ObjetoService objeto_service=Depends(get_objeto_service))</argsstring>
        <name>send_service_state</name>
        <qualifiedname>objeto_controller.send_service_state</qualifiedname>
        <param>
          <type>str</type>
          <declname>osid</declname>
          <defval>Query(..., description=&quot;ID del objeto inteligente&quot;)</defval>
        </param>
        <param>
          <type>ObjetoService</type>
          <declname>objeto_service</declname>
          <defval>Depends(get_objeto_service)</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>    @brief Verifica la disponibilidad/salud del microservicio de datastreams.
    
    @param osid Identificador del objeto inteligente (se incluye en respuesta si se proporciona).
    @param objeto_service Servicio de objetos.
    
    @return JSONResponse con status 200 y disponibilidad del servicio.
    
    @exception RuntimeError Si falla la comprobación de salud del servicio.
    
    @details
    Flujo:
    1. Ejecuta healthcheck contra microservicio_data_stream
    2. Retorna boolean indicando disponibilidad
    3. Opcionalmente incluye osid en respuesta
    
    @note No requiere validación de osid contra el objeto activo
          (es un check genérico de disponibilidad de servicio).
    
    @see ObjetoService.send_service_state()
    
    @example
    GET /objeto/SendServiceState?osid=obj_001
    
    200 OK
    {&quot;service_available&quot;: true, &quot;osid&quot;: &quot;obj_001&quot;}
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/app/api/objeto_controller.py" line="224" column="1" bodyfile="micro_gestion_objetos/app/api/objeto_controller.py" bodystart="224" bodyend="258"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><verbatim>    @file objeto_controller.py
    @brief Controlador REST para gestión de objetos inteligentes.
    @details
    Proporciona endpoints para operaciones CRUD y consultas sobre objetos inteligentes.
    Los endpoints disponibles son:
    - GET /objeto/Identificator: obtener metadatos del objeto
    - POST /objeto/StartObject: iniciar/crear un nuevo objeto inteligente
    - GET /objeto/SendState: obtener estado actual de datastreams
    - GET /objeto/SendData: enviar datos al objeto
    - GET /objeto/SendServiceState: verificar disponibilidad del servicio
    
    @note Todos los endpoints requieren validación de osid (ID del objeto inteligente).
    @note Las operaciones asincrónicas usan asyncio.to_thread() para operaciones bloqueantes.
    
    @author  NexTech
    @version 1.0
    @date 2025-01-10
    
    @see ObjetoService Para lógica de negocio
    @see docs/diagrams/flow_diagrams.md Para diagramas de secuencia
</verbatim> </para>
    </detaileddescription>
    <location file="micro_gestion_objetos/app/api/objeto_controller.py" line="1" column="1"/>
  </compounddef>
</doxygen>

<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="es">
  <compounddef id="namespacetyping__inspection_1_1introspection" kind="namespace" language="Python">
    <compoundname>typing_inspection::introspection</compoundname>
    <innerclass refid="classtyping__inspection_1_1introspection_1_1_annotation_source" prot="public">typing_inspection::introspection::AnnotationSource</innerclass>
    <innerclass refid="classtyping__inspection_1_1introspection_1_1_forbidden_qualifier" prot="public">typing_inspection::introspection::ForbiddenQualifier</innerclass>
    <innerclass refid="classtyping__inspection_1_1introspection_1_1___unknown_type_enum" prot="protected">typing_inspection::introspection::_UnknownTypeEnum</innerclass>
    <innerclass refid="classtyping__inspection_1_1introspection_1_1_inspected_annotation" prot="public">typing_inspection::introspection::InspectedAnnotation</innerclass>
    <sectiondef kind="var">
      <memberdef kind="variable" id="namespacetyping__inspection_1_1introspection_1af086094fef7bb22ede65f88a8492ecaa" prot="public" static="no" mutable="no">
        <type>TypeAlias</type>
        <definition>TypeAlias typing_inspection::introspection.Qualifier</definition>
        <argsstring></argsstring>
        <name>Qualifier</name>
        <qualifiedname>typing_inspection.introspection.Qualifier</qualifiedname>
        <initializer>=  Literal[&apos;required&apos;, &apos;not_required&apos;, &apos;read_only&apos;, &apos;class_var&apos;, &apos;init_var&apos;, &apos;final&apos;]</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" line="215" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" bodystart="215" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetyping__inspection_1_1introspection_1a156c31ee675b75324a3274a590ef9ec4" prot="protected" static="no" mutable="no">
        <type>set</type>
        <definition>set typing_inspection::introspection._all_qualifiers</definition>
        <argsstring></argsstring>
        <name>_all_qualifiers</name>
        <qualifiedname>typing_inspection.introspection._all_qualifiers</qualifiedname>
        <initializer>=  set(get_args(<ref refid="namespacetyping__inspection_1_1introspection_1af086094fef7bb22ede65f88a8492ecaa" kindref="member">Qualifier</ref>))</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" line="218" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" bodystart="218" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetyping__inspection_1_1introspection_1a0807c9abd8d95c099a96e58eadf3e7cb" prot="public" static="no" mutable="no">
        <type></type>
        <definition>typing_inspection::introspection.UNKNOWN</definition>
        <argsstring></argsstring>
        <name>UNKNOWN</name>
        <qualifiedname>typing_inspection.introspection.UNKNOWN</qualifiedname>
        <initializer>=  <ref refid="classtyping__inspection_1_1introspection_1_1___unknown_type_enum_1a764f9313de295759bdaa80aff01b3d2d" kindref="member">_UnknownTypeEnum.UNKNOWN</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" line="356" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" bodystart="356" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetyping__inspection_1_1introspection_1a99d297204dee9aa7a35beb14cfbe41b7" prot="protected" static="no" mutable="no">
        <type>TypeAlias</type>
        <definition>TypeAlias typing_inspection::introspection._UnkownType</definition>
        <argsstring></argsstring>
        <name>_UnkownType</name>
        <qualifiedname>typing_inspection.introspection._UnkownType</qualifiedname>
        <initializer>=  Literal[<ref refid="classtyping__inspection_1_1introspection_1_1___unknown_type_enum_1a764f9313de295759bdaa80aff01b3d2d" kindref="member">_UnknownTypeEnum.UNKNOWN</ref>]</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" line="359" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" bodystart="359" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespacetyping__inspection_1_1introspection_1a7fc3057df37fb18d0d8a0b1da7b91694" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool typing_inspection::introspection::is_union_origin</definition>
        <argsstring>(Any obj)</argsstring>
        <name>is_union_origin</name>
        <qualifiedname>typing_inspection.introspection.is_union_origin</qualifiedname>
        <param>
          <type>Any</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Return whether the provided origin is the union form.

```pycon
&gt;&gt;&gt; is_union_origin(typing.Union)
True
&gt;&gt;&gt; is_union_origin(get_origin(int | str))
True
&gt;&gt;&gt; is_union_origin(types.UnionType)
True
```

!!! note
    Since Python 3.14, both `Union[&lt;t1&gt;, &lt;t2&gt;, ...]` and `&lt;t1&gt; | &lt;t2&gt; | ...` forms create instances
    of the same [`typing.Union`][] class. As such, it is recommended to not use this function
    anymore (provided that you only support Python 3.14 or greater), and instead use the
    [`typing_objects.is_union()`][typing_inspection.typing_objects.is_union] function directly:

    ```python
    from typing import Union, get_origin

    from typing_inspection import typing_objects

    typ = int | str  # Or Union[int, str]
    origin = get_origin(typ)
    if typing_objects.is_union(origin):
        ...
    ```
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" line="28" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" bodystart="28" bodyend="59"/>
      </memberdef>
      <memberdef kind="function" id="namespacetyping__inspection_1_1introspection_1ae186777b66e32813f49f0b114688fad7" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>None</type>
        <definition> None typing_inspection.introspection._literal_type_check</definition>
        <argsstring>(Any value)</argsstring>
        <name>_literal_type_check</name>
        <qualifiedname>typing_inspection.introspection._literal_type_check</qualifiedname>
        <param>
          <type>Any</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Type check the provided literal value against the legal parameters.</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" line="94" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" bodystart="94" bodyend="102"/>
        <referencedby refid="namespacetyping__inspection_1_1introspection_1a87f5650291618da0f858861c30e6e379" compoundref="introspection_8py" startline="109" endline="214">typing_inspection.introspection.get_literal_values</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacetyping__inspection_1_1introspection_1a87f5650291618da0f858861c30e6e379" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Generator[Any]</type>
        <definition> Generator[Any] typing_inspection.introspection.get_literal_values</definition>
        <argsstring>(Any annotation, *, bool type_check=False, Literal[&apos;skip&apos;, &apos;lenient&apos;, &apos;eager&apos;] unpack_type_aliases=&apos;eager&apos;)</argsstring>
        <name>get_literal_values</name>
        <qualifiedname>typing_inspection.introspection.get_literal_values</qualifiedname>
        <param>
          <type>Any</type>
          <declname>annotation</declname>
        </param>
        <param>
          <type>*</type>
        </param>
        <param>
          <type>bool</type>
          <declname>type_check</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>Literal</type>
          <declname>unpack_type_aliases</declname>
          <array>[ &apos;skip&apos;, &apos;lenient&apos;, &apos;eager&apos;]</array>
          <defval>&apos;eager&apos;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Yield the values contained in the provided [`Literal`][typing.Literal] [special form][].

Args:
    annotation: The [`Literal`][typing.Literal] [special form][] to unpack.
    type_check: Whether to check if the literal values are [legal parameters][literal-legal-parameters].
        Raises a [`TypeError`][] otherwise.
    unpack_type_aliases: What to do when encountering [PEP 695](https://peps.python.org/pep-0695/)
        [type aliases][type-aliases]. Can be one of:

        - `&apos;skip&apos;`: Do not try to parse type aliases. Note that this can lead to incorrect results:
          ```pycon
          &gt;&gt;&gt; type MyAlias = Literal[1, 2]
          &gt;&gt;&gt; list(get_literal_values(Literal[MyAlias, 3], unpack_type_aliases=&quot;skip&quot;))
          [MyAlias, 3]
          ```

        - `&apos;lenient&apos;`: Try to parse type aliases, and fallback to `&apos;skip&apos;` if the type alias can&apos;t be inspected
          (because of an undefined forward reference).

        - `&apos;eager&apos;`: Parse type aliases and raise any encountered [`NameError`][] exceptions (the default):
          ```pycon
          &gt;&gt;&gt; type MyAlias = Literal[1, 2]
          &gt;&gt;&gt; list(get_literal_values(Literal[MyAlias, 3], unpack_type_aliases=&quot;eager&quot;))
          [1, 2, 3]
          ```

Note:
    While `None` is [equivalent to][none] `type(None)`, the runtime implementation of [`Literal`][typing.Literal]
    does not de-duplicate them. This function makes sure this de-duplication is applied:

    ```pycon
    &gt;&gt;&gt; list(get_literal_values(Literal[NoneType, None]))
    [None]
    ```

Example:
    ```pycon
    &gt;&gt;&gt; type Ints = Literal[1, 2]
    &gt;&gt;&gt; list(get_literal_values(Literal[1, Ints], unpack_type_alias=&quot;skip&quot;))
    [&quot;a&quot;, Ints]
    &gt;&gt;&gt; list(get_literal_values(Literal[1, Ints]))
    [1, 2]
    &gt;&gt;&gt; list(get_literal_values(Literal[1.0], type_check=True))
    Traceback (most recent call last):
    ...
    TypeError: 1.0 is not a valid literal value, must be one of: int, bytes, str, Enum, None.
    ```
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" line="103" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" bodystart="109" bodyend="214"/>
        <references refid="namespacetyping__inspection_1_1introspection_1ae186777b66e32813f49f0b114688fad7" compoundref="introspection_8py" startline="94" endline="102">typing_inspection.introspection._literal_type_check</references>
        <references refid="namespacetyping__inspection_1_1introspection_1a87f5650291618da0f858861c30e6e379" compoundref="introspection_8py" startline="109" endline="214">typing_inspection.introspection.get_literal_values</references>
        <referencedby refid="namespacetyping__inspection_1_1introspection_1a87f5650291618da0f858861c30e6e379" compoundref="introspection_8py" startline="109" endline="214">typing_inspection.introspection.get_literal_values</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacetyping__inspection_1_1introspection_1aeeb1abad2a48f96bb76b410973fadb7b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtyping__inspection_1_1introspection_1_1_inspected_annotation" kindref="compound">InspectedAnnotation</ref></type>
        <definition> InspectedAnnotation typing_inspection.introspection.inspect_annotation</definition>
        <argsstring>(Any annotation, *, AnnotationSource annotation_source, Literal[&apos;skip&apos;, &apos;lenient&apos;, &apos;eager&apos;] unpack_type_aliases=&apos;skip&apos;)</argsstring>
        <name>inspect_annotation</name>
        <qualifiedname>typing_inspection.introspection.inspect_annotation</qualifiedname>
        <param>
          <type>Any</type>
          <declname>annotation</declname>
        </param>
        <param>
          <type>*</type>
        </param>
        <param>
          <type><ref refid="classtyping__inspection_1_1introspection_1_1_annotation_source" kindref="compound">AnnotationSource</ref></type>
          <declname>annotation_source</declname>
        </param>
        <param>
          <type>Literal</type>
          <declname>unpack_type_aliases</declname>
          <array>[ &apos;skip&apos;, &apos;lenient&apos;, &apos;eager&apos;]</array>
          <defval>&apos;skip&apos;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Inspect an [annotation expression][], extracting any [type qualifier][] and metadata.

An [annotation expression][] is a [type expression][] optionally surrounded by one or more
[type qualifiers][type qualifier] or by [`Annotated`][typing.Annotated]. This function will:

- Unwrap the type expression, keeping track of the type qualifiers.
- Unwrap [`Annotated`][typing.Annotated] forms, keeping track of the annotated metadata.

Args:
    annotation: The annotation expression to be inspected.
    annotation_source: The source of the annotation. Depending on the source (e.g. a class), different type
        qualifiers may be (dis)allowed. To allow any type qualifier, use
        [`AnnotationSource.ANY`][typing_inspection.introspection.AnnotationSource.ANY].
    unpack_type_aliases: What to do when encountering [PEP 695](https://peps.python.org/pep-0695/)
        [type aliases][type-aliases]. Can be one of:

        - `&apos;skip&apos;`: Do not try to parse type aliases (the default):
          ```pycon
          &gt;&gt;&gt; type MyInt = Annotated[int, &apos;meta&apos;]
          &gt;&gt;&gt; inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases=&apos;skip&apos;)
          InspectedAnnotation(type=MyInt, qualifiers={}, metadata=[])
          ```

        - `&apos;lenient&apos;`: Try to parse type aliases, and fallback to `&apos;skip&apos;` if the type alias
          can&apos;t be inspected (because of an undefined forward reference):
          ```pycon
          &gt;&gt;&gt; type MyInt = Annotated[Undefined, &apos;meta&apos;]
          &gt;&gt;&gt; inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases=&apos;lenient&apos;)
          InspectedAnnotation(type=MyInt, qualifiers={}, metadata=[])
          &gt;&gt;&gt; Undefined = int
          &gt;&gt;&gt; inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases=&apos;lenient&apos;)
          InspectedAnnotation(type=int, qualifiers={}, metadata=[&apos;meta&apos;])
          ```

        - `&apos;eager&apos;`: Parse type aliases and raise any encountered [`NameError`][] exceptions.

Returns:
    The result of the inspected annotation, where the type expression, used qualifiers and metadata is stored.

Example:
    ```pycon
    &gt;&gt;&gt; inspect_annotation(
    ...     Final[Annotated[ClassVar[Annotated[int, &apos;meta_1&apos;]], &apos;meta_2&apos;]],
    ...     annotation_source=AnnotationSource.CLASS,
    ... )
    ...
    InspectedAnnotation(type=int, qualifiers={&apos;class_var&apos;, &apos;final&apos;}, metadata=[&apos;meta_1&apos;, &apos;meta_2&apos;])
    ```
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" line="387" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" bodystart="393" bodyend="510"/>
        <references refid="namespacetyping__inspection_1_1introspection_1a6d20009563d406fcaef64a5b547b8709" compoundref="introspection_8py" startline="580" endline="588">typing_inspection.introspection._unpack_annotated</references>
      </memberdef>
      <memberdef kind="function" id="namespacetyping__inspection_1_1introspection_1aca0679748b771dbfe5b707ebfa1876dd" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>tuple[Any, list[Any]]</type>
        <definition> tuple[Any, list[Any]] typing_inspection.introspection._unpack_annotated_inner</definition>
        <argsstring>(Any annotation, Literal[&apos;lenient&apos;, &apos;eager&apos;] unpack_type_aliases, bool check_annotated)</argsstring>
        <name>_unpack_annotated_inner</name>
        <qualifiedname>typing_inspection.introspection._unpack_annotated_inner</qualifiedname>
        <param>
          <type>Any</type>
          <declname>annotation</declname>
        </param>
        <param>
          <type>Literal</type>
          <declname>unpack_type_aliases</declname>
          <array>[ &apos;lenient&apos;, &apos;eager&apos;]</array>
        </param>
        <param>
          <type>bool</type>
          <declname>check_annotated</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" line="511" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" bodystart="513" bodyend="577"/>
        <references refid="namespacetyping__inspection_1_1introspection_1aca0679748b771dbfe5b707ebfa1876dd" compoundref="introspection_8py" startline="513" endline="577">typing_inspection.introspection._unpack_annotated_inner</references>
        <referencedby refid="namespacetyping__inspection_1_1introspection_1a6d20009563d406fcaef64a5b547b8709" compoundref="introspection_8py" startline="580" endline="588">typing_inspection.introspection._unpack_annotated</referencedby>
        <referencedby refid="namespacetyping__inspection_1_1introspection_1aca0679748b771dbfe5b707ebfa1876dd" compoundref="introspection_8py" startline="513" endline="577">typing_inspection.introspection._unpack_annotated_inner</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacetyping__inspection_1_1introspection_1a6d20009563d406fcaef64a5b547b8709" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>tuple[Any, list[Any]]</type>
        <definition> tuple[Any, list[Any]] typing_inspection.introspection._unpack_annotated</definition>
        <argsstring>(Any annotation, *, Literal[&apos;skip&apos;, &apos;lenient&apos;, &apos;eager&apos;] unpack_type_aliases=&apos;eager&apos;)</argsstring>
        <name>_unpack_annotated</name>
        <qualifiedname>typing_inspection.introspection._unpack_annotated</qualifiedname>
        <param>
          <type>Any</type>
          <declname>annotation</declname>
        </param>
        <param>
          <type>*</type>
        </param>
        <param>
          <type>Literal</type>
          <declname>unpack_type_aliases</declname>
          <array>[ &apos;skip&apos;, &apos;lenient&apos;, &apos;eager&apos;]</array>
          <defval>&apos;eager&apos;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" line="578" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" bodystart="580" bodyend="588"/>
        <references refid="namespacetyping__inspection_1_1introspection_1aca0679748b771dbfe5b707ebfa1876dd" compoundref="introspection_8py" startline="513" endline="577">typing_inspection.introspection._unpack_annotated_inner</references>
        <referencedby refid="namespacetyping__inspection_1_1introspection_1aeeb1abad2a48f96bb76b410973fadb7b" compoundref="introspection_8py" startline="393" endline="510">typing_inspection.introspection.inspect_annotation</referencedby>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><verbatim>High-level introspection utilities, used to inspect type annotations.</verbatim> </para>
    </detaileddescription>
    <location file="micro_gestion_objetos/venv/Lib/site-packages/typing_inspection/introspection.py" line="1" column="1"/>
  </compounddef>
</doxygen>

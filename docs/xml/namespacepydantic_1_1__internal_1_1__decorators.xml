<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="es">
  <compounddef id="namespacepydantic_1_1__internal_1_1__decorators" kind="namespace" language="Python">
    <compoundname>pydantic::_internal::_decorators</compoundname>
    <innerclass refid="classpydantic_1_1__internal_1_1__decorators_1_1_validator_decorator_info" prot="public">pydantic::_internal::_decorators::ValidatorDecoratorInfo</innerclass>
    <innerclass refid="classpydantic_1_1__internal_1_1__decorators_1_1_field_validator_decorator_info" prot="public">pydantic::_internal::_decorators::FieldValidatorDecoratorInfo</innerclass>
    <innerclass refid="classpydantic_1_1__internal_1_1__decorators_1_1_root_validator_decorator_info" prot="public">pydantic::_internal::_decorators::RootValidatorDecoratorInfo</innerclass>
    <innerclass refid="classpydantic_1_1__internal_1_1__decorators_1_1_field_serializer_decorator_info" prot="public">pydantic::_internal::_decorators::FieldSerializerDecoratorInfo</innerclass>
    <innerclass refid="classpydantic_1_1__internal_1_1__decorators_1_1_model_serializer_decorator_info" prot="public">pydantic::_internal::_decorators::ModelSerializerDecoratorInfo</innerclass>
    <innerclass refid="classpydantic_1_1__internal_1_1__decorators_1_1_model_validator_decorator_info" prot="public">pydantic::_internal::_decorators::ModelValidatorDecoratorInfo</innerclass>
    <innerclass refid="classpydantic_1_1__internal_1_1__decorators_1_1_pydantic_descriptor_proxy" prot="public">pydantic::_internal::_decorators::PydanticDescriptorProxy</innerclass>
    <innerclass refid="classpydantic_1_1__internal_1_1__decorators_1_1_decorator" prot="public">pydantic::_internal::_decorators::Decorator</innerclass>
    <innerclass refid="classpydantic_1_1__internal_1_1__decorators_1_1_decorator_infos" prot="public">pydantic::_internal::_decorators::DecoratorInfos</innerclass>
    <sectiondef kind="var">
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__decorators_1af032c0644a62eb719c04068d072e012e" prot="public" static="no" mutable="no">
        <type></type>
        <definition>pydantic::_internal::_decorators.ReturnType</definition>
        <argsstring></argsstring>
        <name>ReturnType</name>
        <qualifiedname>pydantic._internal._decorators.ReturnType</qualifiedname>
        <initializer>=  TypeVar(&apos;ReturnType&apos;)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="158" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="158" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__decorators_1a9261455a29c3480758acb335df662e50" prot="public" static="no" mutable="no">
        <type>tuple</type>
        <definition>tuple pydantic::_internal::_decorators.DecoratedType</definition>
        <argsstring></argsstring>
        <name>DecoratedType</name>
        <qualifiedname>pydantic._internal._decorators.DecoratedType</qualifiedname>
        <initializer>=  (
    &apos;Union[classmethod[Any, Any, <ref refid="namespacepydantic_1_1__internal_1_1__decorators_1af032c0644a62eb719c04068d072e012e" kindref="member">ReturnType</ref>], staticmethod[Any, <ref refid="namespacepydantic_1_1__internal_1_1__decorators_1af032c0644a62eb719c04068d072e012e" kindref="member">ReturnType</ref>], Callable[..., <ref refid="namespacepydantic_1_1__internal_1_1__decorators_1af032c0644a62eb719c04068d072e012e" kindref="member">ReturnType</ref>], property]&apos;
)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="159" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="159" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__decorators_1a53c1d30f810261b44c8c2f6f0ba88e8e" prot="public" static="no" mutable="no">
        <type></type>
        <definition>pydantic::_internal::_decorators.DecoratorInfoType</definition>
        <argsstring></argsstring>
        <name>DecoratorInfoType</name>
        <qualifiedname>pydantic._internal._decorators.DecoratorInfoType</qualifiedname>
        <initializer>=  TypeVar(&apos;DecoratorInfoType&apos;, bound=DecoratorInfo)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="215" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="215" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__decorators_1a95429705ec7864a4d281d005b9ae70db" prot="protected" static="no" mutable="no">
        <type></type>
        <definition>pydantic::_internal::_decorators._sentinel</definition>
        <argsstring></argsstring>
        <name>_sentinel</name>
        <qualifiedname>pydantic._internal._decorators._sentinel</qualifiedname>
        <initializer>=  object()</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="355" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="355" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__decorators_1a5f876a0dc0191fe8f3b1f00c7377422b" prot="public" static="no" mutable="no">
        <type>tuple</type>
        <definition>tuple pydantic::_internal::_decorators.AnyDecoratorCallable</definition>
        <argsstring></argsstring>
        <name>AnyDecoratorCallable</name>
        <qualifiedname>pydantic._internal._decorators.AnyDecoratorCallable</qualifiedname>
        <initializer>=  (
    &apos;Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any], Callable[..., Any]]&apos;
)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="680" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="680" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__decorators_1ad9401bb67737bcf6173a4bda3f37164a" prot="protected" static="no" mutable="no">
        <type>tuple</type>
        <definition>tuple pydantic::_internal::_decorators._function_like</definition>
        <argsstring></argsstring>
        <name>_function_like</name>
        <qualifiedname>pydantic._internal._decorators._function_like</qualifiedname>
        <initializer>=  (
    partial,
    partialmethod,
    types.FunctionType,
    types.BuiltinFunctionType,
    types.MethodType,
    types.WrapperDescriptorType,
    types.MethodWrapperType,
    types.MemberDescriptorType,
)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="768" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="768" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a296dc7955e451ea19f3fca316f565003" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>tuple[type[Any],...]</type>
        <definition> tuple[type[Any], ...] pydantic._internal._decorators.get_bases</definition>
        <argsstring>(type[Any] tp)</argsstring>
        <name>get_bases</name>
        <qualifiedname>pydantic._internal._decorators.get_bases</qualifiedname>
        <param>
          <type>type</type>
          <declname>tp</declname>
          <array>[Any]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Get the base classes of a class or typeddict.

Args:
    tp: The type or class to get the bases.

Returns:
    The base classes.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="292" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="292" bodyend="308"/>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a46bce8b6a99c1d674691b7e51ae4dd43" compoundref="__decorators_8py" startline="309" endline="326">pydantic._internal._decorators.mro</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a46bce8b6a99c1d674691b7e51ae4dd43" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>tuple[type[Any],...]</type>
        <definition> tuple[type[Any], ...] pydantic._internal._decorators.mro</definition>
        <argsstring>(type[Any] tp)</argsstring>
        <name>mro</name>
        <qualifiedname>pydantic._internal._decorators.mro</qualifiedname>
        <param>
          <type>type</type>
          <declname>tp</declname>
          <array>[Any]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Calculate the Method Resolution Order of bases using the C3 algorithm.

See https://www.python.org/download/releases/2.3/mro/
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="309" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="309" bodyend="326"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a296dc7955e451ea19f3fca316f565003" compoundref="__decorators_8py" startline="292" endline="308">pydantic._internal._decorators.get_bases</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a438239d2a82f4a18eabb4f4a53e423ea" compoundref="__decorators_8py" startline="327" endline="354">pydantic._internal._decorators.mro_for_bases</references>
        <referencedby refid="classpydantic_1_1__internal_1_1__decorators_1_1_decorator_infos_1a48661763761e67993a5749629b664dae" compoundref="__decorators_8py" startline="431" endline="518">pydantic._internal._decorators.DecoratorInfos.build</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a809204b834e5f9411b2146cce20cf011" compoundref="__decorators_8py" startline="393" endline="414">pydantic._internal._decorators.get_attribute_from_base_dicts</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a3d3f0dbb7efd36d7d0527e9c7174a2ec" compoundref="__decorators_8py" startline="358" endline="392">pydantic._internal._decorators.get_attribute_from_bases</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a438239d2a82f4a18eabb4f4a53e423ea" compoundref="__decorators_8py" startline="327" endline="354">pydantic._internal._decorators.mro_for_bases</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a438239d2a82f4a18eabb4f4a53e423ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>tuple[type[Any],...]</type>
        <definition> tuple[type[Any], ...] pydantic._internal._decorators.mro_for_bases</definition>
        <argsstring>(tuple[type[Any],...] bases)</argsstring>
        <name>mro_for_bases</name>
        <qualifiedname>pydantic._internal._decorators.mro_for_bases</qualifiedname>
        <param>
          <type>tuple</type>
          <defname>bases</defname>
          <array>[type[Any]</array>
        </param>
        <param>
          <type>...]</type>
          <declname>bases</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="327" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="327" bodyend="354"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a46bce8b6a99c1d674691b7e51ae4dd43" compoundref="__decorators_8py" startline="309" endline="326">pydantic._internal._decorators.mro</references>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a3d3f0dbb7efd36d7d0527e9c7174a2ec" compoundref="__decorators_8py" startline="358" endline="392">pydantic._internal._decorators.get_attribute_from_bases</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a46bce8b6a99c1d674691b7e51ae4dd43" compoundref="__decorators_8py" startline="309" endline="326">pydantic._internal._decorators.mro</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a3d3f0dbb7efd36d7d0527e9c7174a2ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Any</type>
        <definition> Any pydantic._internal._decorators.get_attribute_from_bases</definition>
        <argsstring>(type[Any]|tuple[type[Any],...] tp, str name)</argsstring>
        <name>get_attribute_from_bases</name>
        <qualifiedname>pydantic._internal._decorators.get_attribute_from_bases</qualifiedname>
        <param>
          <type>type|</type>
          <declname>tuple</declname>
          <defname>tp</defname>
          <array>[Any][type[Any]</array>
        </param>
        <param>
          <type>...]</type>
          <declname>tp</declname>
          <defname>name</defname>
        </param>
        <param>
          <type>str</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Get the attribute from the next class in the MRO that has it,
aiming to simulate calling the method on the actual class.

The reason for iterating over the mro instead of just getting
the attribute (which would do that for us) is to support TypedDict,
which lacks a real __mro__, but can have a virtual one constructed
from its bases (as done here).

Args:
    tp: The type or class to search for the attribute. If a tuple, this is treated as a set of base classes.
    name: The name of the attribute to retrieve.

Returns:
    Any: The attribute value, if found.

Raises:
    AttributeError: If the attribute is not found in any class in the MRO.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="358" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="358" bodyend="392"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a3d3f0dbb7efd36d7d0527e9c7174a2ec" compoundref="__decorators_8py" startline="358" endline="392">pydantic._internal._decorators.get_attribute_from_bases</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a46bce8b6a99c1d674691b7e51ae4dd43" compoundref="__decorators_8py" startline="309" endline="326">pydantic._internal._decorators.mro</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a438239d2a82f4a18eabb4f4a53e423ea" compoundref="__decorators_8py" startline="327" endline="354">pydantic._internal._decorators.mro_for_bases</references>
        <referencedby refid="classpydantic_1_1__internal_1_1__decorators_1_1_decorator_1a781ebb87664e600f3e828a51ebaee469" compoundref="__decorators_8py" startline="246" endline="274">pydantic._internal._decorators.Decorator.build</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a3d3f0dbb7efd36d7d0527e9c7174a2ec" compoundref="__decorators_8py" startline="358" endline="392">pydantic._internal._decorators.get_attribute_from_bases</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a809204b834e5f9411b2146cce20cf011" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Any</type>
        <definition> Any pydantic._internal._decorators.get_attribute_from_base_dicts</definition>
        <argsstring>(type[Any] tp, str name)</argsstring>
        <name>get_attribute_from_base_dicts</name>
        <qualifiedname>pydantic._internal._decorators.get_attribute_from_base_dicts</qualifiedname>
        <param>
          <type>type</type>
          <declname>tp</declname>
          <array>[Any]</array>
        </param>
        <param>
          <type>str</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Get an attribute out of the `__dict__` following the MRO.
This prevents the call to `__get__` on the descriptor, and allows
us to get the original function for classmethod properties.

Args:
    tp: The type or class to search for the attribute.
    name: The name of the attribute to retrieve.

Returns:
    Any: The attribute value, if found.

Raises:
    KeyError: If the attribute is not found in any class&apos;s `__dict__` in the MRO.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="393" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="393" bodyend="414"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a46bce8b6a99c1d674691b7e51ae4dd43" compoundref="__decorators_8py" startline="309" endline="326">pydantic._internal._decorators.mro</references>
        <referencedby refid="classpydantic_1_1__internal_1_1__decorators_1_1_decorator_1a781ebb87664e600f3e828a51ebaee469" compoundref="__decorators_8py" startline="246" endline="274">pydantic._internal._decorators.Decorator.build</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a22e242c3860b2006ff831526384fe973" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition> bool pydantic._internal._decorators.inspect_validator</definition>
        <argsstring>(Callable[..., Any] validator, *, FieldValidatorModes mode, Literal[&apos;field&apos;, &apos;model&apos;] type)</argsstring>
        <name>inspect_validator</name>
        <qualifiedname>pydantic._internal._decorators.inspect_validator</qualifiedname>
        <param>
          <type>Callable</type>
          <declname>validator</declname>
          <array>[..., Any]</array>
        </param>
        <param>
          <type>*</type>
        </param>
        <param>
          <type>FieldValidatorModes</type>
          <declname>mode</declname>
        </param>
        <param>
          <type>Literal</type>
          <declname>type</declname>
          <array>[ &apos;field&apos;, &apos;model&apos;]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Look at a field or model validator function and determine whether it takes an info argument.

An error is raised if the function has an invalid signature.

Args:
    validator: The validator function to inspect.
    mode: The proposed validator mode.
    type: The type of validator, either &apos;field&apos; or &apos;model&apos;.

Returns:
    Whether the validator takes an info argument.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="525" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="527" bodyend="564"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a1d6d69c0f75f0c8dd9102f0aa1d5c5d1" compoundref="__decorators_8py" startline="851" endline="859">pydantic._internal._decorators._signature_no_eval</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a33c999b67f11943ab6af9b68df722bbc" compoundref="__decorators_8py" startline="814" endline="835">pydantic._internal._decorators.count_positional_required_params</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1ac6a220489a3d0295ce514e139f07d3ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>tuple[bool, bool]</type>
        <definition> tuple[bool, bool] pydantic._internal._decorators.inspect_field_serializer</definition>
        <argsstring>(Callable[..., Any] serializer, Literal[&apos;plain&apos;, &apos;wrap&apos;] mode)</argsstring>
        <name>inspect_field_serializer</name>
        <qualifiedname>pydantic._internal._decorators.inspect_field_serializer</qualifiedname>
        <param>
          <type>Callable</type>
          <declname>serializer</declname>
          <array>[..., Any]</array>
        </param>
        <param>
          <type>Literal</type>
          <declname>mode</declname>
          <array>[ &apos;plain&apos;, &apos;wrap&apos;]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Look at a field serializer function and determine if it is a field serializer,
and whether it takes an info argument.

An error is raised if the function has an invalid signature.

Args:
    serializer: The serializer function to inspect.
    mode: The serializer mode, either &apos;plain&apos; or &apos;wrap&apos;.

Returns:
    Tuple of (is_field_serializer, info_arg).
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="565" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="565" bodyend="603"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1acf6967d64d088ef9531373d5a25d8e39" compoundref="__decorators_8py" startline="660" endline="679">pydantic._internal._decorators._serializer_info_arg</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a1d6d69c0f75f0c8dd9102f0aa1d5c5d1" compoundref="__decorators_8py" startline="851" endline="859">pydantic._internal._decorators._signature_no_eval</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a33c999b67f11943ab6af9b68df722bbc" compoundref="__decorators_8py" startline="814" endline="835">pydantic._internal._decorators.count_positional_required_params</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1ab116b99c933ee00798895da5848c6b01" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition> bool pydantic._internal._decorators.inspect_annotated_serializer</definition>
        <argsstring>(Callable[..., Any] serializer, Literal[&apos;plain&apos;, &apos;wrap&apos;] mode)</argsstring>
        <name>inspect_annotated_serializer</name>
        <qualifiedname>pydantic._internal._decorators.inspect_annotated_serializer</qualifiedname>
        <param>
          <type>Callable</type>
          <declname>serializer</declname>
          <array>[..., Any]</array>
        </param>
        <param>
          <type>Literal</type>
          <declname>mode</declname>
          <array>[ &apos;plain&apos;, &apos;wrap&apos;]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Look at a serializer function used via `Annotated` and determine whether it takes an info argument.

An error is raised if the function has an invalid signature.

Args:
    serializer: The serializer function to check.
    mode: The serializer mode, either &apos;plain&apos; or &apos;wrap&apos;.

Returns:
    info_arg
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="604" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="604" bodyend="631"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1acf6967d64d088ef9531373d5a25d8e39" compoundref="__decorators_8py" startline="660" endline="679">pydantic._internal._decorators._serializer_info_arg</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a1d6d69c0f75f0c8dd9102f0aa1d5c5d1" compoundref="__decorators_8py" startline="851" endline="859">pydantic._internal._decorators._signature_no_eval</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a33c999b67f11943ab6af9b68df722bbc" compoundref="__decorators_8py" startline="814" endline="835">pydantic._internal._decorators.count_positional_required_params</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a5839ab2cd7ab1bba19819dfe24663f66" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition> bool pydantic._internal._decorators.inspect_model_serializer</definition>
        <argsstring>(Callable[..., Any] serializer, Literal[&apos;plain&apos;, &apos;wrap&apos;] mode)</argsstring>
        <name>inspect_model_serializer</name>
        <qualifiedname>pydantic._internal._decorators.inspect_model_serializer</qualifiedname>
        <param>
          <type>Callable</type>
          <declname>serializer</declname>
          <array>[..., Any]</array>
        </param>
        <param>
          <type>Literal</type>
          <declname>mode</declname>
          <array>[ &apos;plain&apos;, &apos;wrap&apos;]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Look at a model serializer function and determine whether it takes an info argument.

An error is raised if the function has an invalid signature.

Args:
    serializer: The serializer function to check.
    mode: The serializer mode, either &apos;plain&apos; or &apos;wrap&apos;.

Returns:
    `info_arg` - whether the function expects an info argument.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="632" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="632" bodyend="659"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1acf6967d64d088ef9531373d5a25d8e39" compoundref="__decorators_8py" startline="660" endline="679">pydantic._internal._decorators._serializer_info_arg</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a1d6d69c0f75f0c8dd9102f0aa1d5c5d1" compoundref="__decorators_8py" startline="851" endline="859">pydantic._internal._decorators._signature_no_eval</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a33c999b67f11943ab6af9b68df722bbc" compoundref="__decorators_8py" startline="814" endline="835">pydantic._internal._decorators.count_positional_required_params</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1af1f7972c6dacdc3457caa54df90b2185" compoundref="__decorators_8py" startline="685" endline="703">pydantic._internal._decorators.is_instance_method_from_sig</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1acf6967d64d088ef9531373d5a25d8e39" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool|None</type>
        <definition> bool | None pydantic._internal._decorators._serializer_info_arg</definition>
        <argsstring>(Literal[&apos;plain&apos;, &apos;wrap&apos;] mode, int n_positional)</argsstring>
        <name>_serializer_info_arg</name>
        <qualifiedname>pydantic._internal._decorators._serializer_info_arg</qualifiedname>
        <param>
          <type>Literal</type>
          <declname>mode</declname>
          <array>[ &apos;plain&apos;, &apos;wrap&apos;]</array>
        </param>
        <param>
          <type>int</type>
          <declname>n_positional</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="660" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="660" bodyend="679"/>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1ab116b99c933ee00798895da5848c6b01" compoundref="__decorators_8py" startline="604" endline="631">pydantic._internal._decorators.inspect_annotated_serializer</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1ac6a220489a3d0295ce514e139f07d3ef" compoundref="__decorators_8py" startline="565" endline="603">pydantic._internal._decorators.inspect_field_serializer</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a5839ab2cd7ab1bba19819dfe24663f66" compoundref="__decorators_8py" startline="632" endline="659">pydantic._internal._decorators.inspect_model_serializer</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1af1f7972c6dacdc3457caa54df90b2185" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition> bool pydantic._internal._decorators.is_instance_method_from_sig</definition>
        <argsstring>(AnyDecoratorCallable function)</argsstring>
        <name>is_instance_method_from_sig</name>
        <qualifiedname>pydantic._internal._decorators.is_instance_method_from_sig</qualifiedname>
        <param>
          <type><ref refid="namespacepydantic_1_1__internal_1_1__decorators_1a5f876a0dc0191fe8f3b1f00c7377422b" kindref="member">AnyDecoratorCallable</ref></type>
          <declname>function</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Whether the function is an instance method.

It will consider a function as instance method if the first parameter of
function is `self`.

Args:
    function: The function to check.

Returns:
    `True` if the function is an instance method, `False` otherwise.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="685" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="685" bodyend="703"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a1d6d69c0f75f0c8dd9102f0aa1d5c5d1" compoundref="__decorators_8py" startline="851" endline="859">pydantic._internal._decorators._signature_no_eval</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1adfad5e6d1394d62000cb1de4701d46d7" compoundref="__decorators_8py" startline="733" endline="767">pydantic._internal._decorators.unwrap_wrapped_function</references>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a5839ab2cd7ab1bba19819dfe24663f66" compoundref="__decorators_8py" startline="632" endline="659">pydantic._internal._decorators.inspect_model_serializer</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a078a4a3598a8cfebbd20f96355ba814f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Any</type>
        <definition> Any pydantic._internal._decorators.ensure_classmethod_based_on_signature</definition>
        <argsstring>(AnyDecoratorCallable function)</argsstring>
        <name>ensure_classmethod_based_on_signature</name>
        <qualifiedname>pydantic._internal._decorators.ensure_classmethod_based_on_signature</qualifiedname>
        <param>
          <type><ref refid="namespacepydantic_1_1__internal_1_1__decorators_1a5f876a0dc0191fe8f3b1f00c7377422b" kindref="member">AnyDecoratorCallable</ref></type>
          <declname>function</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Apply the `@classmethod` decorator on the function.

Args:
    function: The function to apply the decorator on.

Return:
    The `@classmethod` decorator applied function.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="704" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="704" bodyend="719"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a1af5f616a877f11ed7bba7b88f06477b" compoundref="__decorators_8py" startline="720" endline="727">pydantic._internal._decorators._is_classmethod_from_sig</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1adfad5e6d1394d62000cb1de4701d46d7" compoundref="__decorators_8py" startline="733" endline="767">pydantic._internal._decorators.unwrap_wrapped_function</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a1af5f616a877f11ed7bba7b88f06477b" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition> bool pydantic._internal._decorators._is_classmethod_from_sig</definition>
        <argsstring>(AnyDecoratorCallable function)</argsstring>
        <name>_is_classmethod_from_sig</name>
        <qualifiedname>pydantic._internal._decorators._is_classmethod_from_sig</qualifiedname>
        <param>
          <type><ref refid="namespacepydantic_1_1__internal_1_1__decorators_1a5f876a0dc0191fe8f3b1f00c7377422b" kindref="member">AnyDecoratorCallable</ref></type>
          <declname>function</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="720" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="720" bodyend="727"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1a1d6d69c0f75f0c8dd9102f0aa1d5c5d1" compoundref="__decorators_8py" startline="851" endline="859">pydantic._internal._decorators._signature_no_eval</references>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1adfad5e6d1394d62000cb1de4701d46d7" compoundref="__decorators_8py" startline="733" endline="767">pydantic._internal._decorators.unwrap_wrapped_function</references>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a078a4a3598a8cfebbd20f96355ba814f" compoundref="__decorators_8py" startline="704" endline="719">pydantic._internal._decorators.ensure_classmethod_based_on_signature</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1adfad5e6d1394d62000cb1de4701d46d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Any</type>
        <definition> Any pydantic._internal._decorators.unwrap_wrapped_function</definition>
        <argsstring>(Any func, *, bool unwrap_partial=True, bool unwrap_class_static_method=True)</argsstring>
        <name>unwrap_wrapped_function</name>
        <qualifiedname>pydantic._internal._decorators.unwrap_wrapped_function</qualifiedname>
        <param>
          <type>Any</type>
          <declname>func</declname>
        </param>
        <param>
          <type>*</type>
        </param>
        <param>
          <type>bool</type>
          <declname>unwrap_partial</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>unwrap_class_static_method</declname>
          <defval>True</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Recursively unwraps a wrapped function until the underlying function is reached.
This handles property, functools.partial, functools.partialmethod, staticmethod, and classmethod.

Args:
    func: The function to unwrap.
    unwrap_partial: If True (default), unwrap partial and partialmethod decorators.
    unwrap_class_static_method: If True (default), also unwrap classmethod and staticmethod
        decorators. If False, only unwrap partial and partialmethod decorators.

Returns:
    The underlying function of the wrapped function.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="728" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="733" bodyend="767"/>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a1af5f616a877f11ed7bba7b88f06477b" compoundref="__decorators_8py" startline="720" endline="727">pydantic._internal._decorators._is_classmethod_from_sig</referencedby>
        <referencedby refid="classpydantic_1_1__internal_1_1__decorators_1_1_decorator_1a781ebb87664e600f3e828a51ebaee469" compoundref="__decorators_8py" startline="246" endline="274">pydantic._internal._decorators.Decorator.build</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a078a4a3598a8cfebbd20f96355ba814f" compoundref="__decorators_8py" startline="704" endline="719">pydantic._internal._decorators.ensure_classmethod_based_on_signature</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a027f978994f6bc7218d72fc0a4ee2097" compoundref="__decorators_8py" startline="784" endline="813">pydantic._internal._decorators.get_callable_return_type</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1af1f7972c6dacdc3457caa54df90b2185" compoundref="__decorators_8py" startline="685" endline="703">pydantic._internal._decorators.is_instance_method_from_sig</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a027f978994f6bc7218d72fc0a4ee2097" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Any|PydanticUndefinedType</type>
        <definition> Any | PydanticUndefinedType pydantic._internal._decorators.get_callable_return_type</definition>
        <argsstring>(Any callable_obj, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None)</argsstring>
        <name>get_callable_return_type</name>
        <qualifiedname>pydantic._internal._decorators.get_callable_return_type</qualifiedname>
        <param>
          <type>Any</type>
          <declname>callable_obj</declname>
        </param>
        <param>
          <type>GlobalsNamespace|None</type>
          <declname>globalns</declname>
          <defval>None</defval>
        </param>
        <param>
          <type>MappingNamespace|None</type>
          <declname>localns</declname>
          <defval>None</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Get the callable return type.

Args:
    callable_obj: The callable to analyze.
    globalns: The globals namespace to use during type annotation evaluation.
    localns: The locals namespace to use during type annotation evaluation.

Returns:
    The function return type.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="780" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="784" bodyend="813"/>
        <references refid="namespacepydantic_1_1__internal_1_1__decorators_1adfad5e6d1394d62000cb1de4701d46d7" compoundref="__decorators_8py" startline="733" endline="767">pydantic._internal._decorators.unwrap_wrapped_function</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a33c999b67f11943ab6af9b68df722bbc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition> int pydantic._internal._decorators.count_positional_required_params</definition>
        <argsstring>(Signature sig)</argsstring>
        <name>count_positional_required_params</name>
        <qualifiedname>pydantic._internal._decorators.count_positional_required_params</qualifiedname>
        <param>
          <type>Signature</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Get the number of positional (required) arguments of a signature.

This function should only be used to inspect signatures of validation and serialization functions.
The first argument (the value being serialized or validated) is counted as a required argument
even if a default value exists.

Returns:
    The number of positional arguments of a signature.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="814" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="814" bodyend="835"/>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1ab116b99c933ee00798895da5848c6b01" compoundref="__decorators_8py" startline="604" endline="631">pydantic._internal._decorators.inspect_annotated_serializer</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1ac6a220489a3d0295ce514e139f07d3ef" compoundref="__decorators_8py" startline="565" endline="603">pydantic._internal._decorators.inspect_field_serializer</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a5839ab2cd7ab1bba19819dfe24663f66" compoundref="__decorators_8py" startline="632" endline="659">pydantic._internal._decorators.inspect_model_serializer</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a22e242c3860b2006ff831526384fe973" compoundref="__decorators_8py" startline="527" endline="564">pydantic._internal._decorators.inspect_validator</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1acaf5ab2a2adfb2b76b7d48140bd8d0ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Any</type>
        <definition> Any pydantic._internal._decorators.ensure_property</definition>
        <argsstring>(Any f)</argsstring>
        <name>ensure_property</name>
        <qualifiedname>pydantic._internal._decorators.ensure_property</qualifiedname>
        <param>
          <type>Any</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Ensure that a function is a `property` or `cached_property`, or is a valid descriptor.

Args:
    f: The function to check.

Returns:
    The function, or a `property` or `cached_property` instance wrapping the function.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="836" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="836" bodyend="850"/>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__decorators_1a1d6d69c0f75f0c8dd9102f0aa1d5c5d1" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Signature</type>
        <definition> Signature pydantic._internal._decorators._signature_no_eval</definition>
        <argsstring>(Callable[..., Any] f)</argsstring>
        <name>_signature_no_eval</name>
        <qualifiedname>pydantic._internal._decorators._signature_no_eval</qualifiedname>
        <param>
          <type>Callable</type>
          <declname>f</declname>
          <array>[..., Any]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Get the signature of a callable without evaluating any annotations.</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="851" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" bodystart="851" bodyend="859"/>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a1af5f616a877f11ed7bba7b88f06477b" compoundref="__decorators_8py" startline="720" endline="727">pydantic._internal._decorators._is_classmethod_from_sig</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1ab116b99c933ee00798895da5848c6b01" compoundref="__decorators_8py" startline="604" endline="631">pydantic._internal._decorators.inspect_annotated_serializer</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1ac6a220489a3d0295ce514e139f07d3ef" compoundref="__decorators_8py" startline="565" endline="603">pydantic._internal._decorators.inspect_field_serializer</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a5839ab2cd7ab1bba19819dfe24663f66" compoundref="__decorators_8py" startline="632" endline="659">pydantic._internal._decorators.inspect_model_serializer</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1a22e242c3860b2006ff831526384fe973" compoundref="__decorators_8py" startline="527" endline="564">pydantic._internal._decorators.inspect_validator</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__decorators_1af1f7972c6dacdc3457caa54df90b2185" compoundref="__decorators_8py" startline="685" endline="703">pydantic._internal._decorators.is_instance_method_from_sig</referencedby>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><verbatim>Logic related to validators applied to models etc. via the `@field_validator` and `@model_validator` decorators.</verbatim> </para>
    </detaileddescription>
    <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_decorators.py" line="1" column="1"/>
  </compounddef>
</doxygen>

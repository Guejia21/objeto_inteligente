<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="es">
  <compounddef id="namespacepydantic_1_1v1_1_1dataclasses" kind="namespace" language="Python">
    <compoundname>pydantic::v1::dataclasses</compoundname>
    <innerclass refid="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass" prot="public">pydantic::v1::dataclasses::Dataclass</innerclass>
    <innerclass refid="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass_proxy" prot="public">pydantic::v1::dataclasses::DataclassProxy</innerclass>
    <sectiondef kind="var">
      <memberdef kind="variable" id="namespacepydantic_1_1v1_1_1dataclasses_1a455aa88f8b87f292307d5dc5f1008768" prot="public" static="no" mutable="no">
        <type></type>
        <definition>pydantic::v1::dataclasses.DataclassT</definition>
        <argsstring></argsstring>
        <name>DataclassT</name>
        <qualifiedname>pydantic.v1.dataclasses.DataclassT</qualifiedname>
        <initializer>=  TypeVar(&apos;DataclassT&apos;, bound=&apos;<ref refid="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass" kindref="compound">Dataclass</ref>&apos;)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="62" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="62" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1v1_1_1dataclasses_1a2d7331ed35801d80fad6ccee5cb2ef3b" prot="public" static="no" mutable="no">
        <type></type>
        <definition>pydantic::v1::dataclasses.DataclassClassOrWrapper</definition>
        <argsstring></argsstring>
        <name>DataclassClassOrWrapper</name>
        <qualifiedname>pydantic.v1.dataclasses.DataclassClassOrWrapper</qualifiedname>
        <initializer>=  Union[Type[&apos;<ref refid="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass" kindref="compound">Dataclass</ref>&apos;], &apos;<ref refid="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass_proxy" kindref="compound">DataclassProxy</ref>&apos;]</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="64" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="64" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1v1_1_1dataclasses_1a4653ece05ae4bf55c30e16b8d3318cc7" prot="protected" static="no" mutable="no">
        <type></type>
        <definition>pydantic::v1::dataclasses._T</definition>
        <argsstring></argsstring>
        <name>_T</name>
        <qualifiedname>pydantic.v1.dataclasses._T</qualifiedname>
        <initializer>=  TypeVar(&apos;_T&apos;)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="100" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="100" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1abf55055adb13a482aaaf1f4301b44238" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Callable[[Type[<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a4653ece05ae4bf55c30e16b8d3318cc7" kindref="member">_T</ref>]], &apos;<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a2d7331ed35801d80fad6ccee5cb2ef3b" kindref="member">DataclassClassOrWrapper</ref>&apos;]</type>
        <definition> Callable[[Type[_T]], &apos;DataclassClassOrWrapper&apos;] pydantic.v1.dataclasses.dataclass</definition>
        <argsstring>(*, bool init=True, bool repr=True, bool eq=True, bool order=False, bool unsafe_hash=False, bool frozen=False, Union[ConfigDict, Type[object], None] config=None, Optional[bool] validate_on_init=None, Optional[bool] use_proxy=None, bool kw_only=...)</argsstring>
        <name>dataclass</name>
        <qualifiedname>pydantic.v1.dataclasses.dataclass</qualifiedname>
        <param>
          <type>*</type>
        </param>
        <param>
          <type>bool</type>
          <declname>init</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>repr</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>eq</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>order</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>unsafe_hash</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>frozen</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>Union</type>
          <defname>config</defname>
          <array>[ConfigDict, Type[object]</array>
        </param>
        <param>
          <type>None]</type>
          <declname>config</declname>
          <defname>validate_on_init</defname>
          <defval>None</defval>
        </param>
        <param>
          <type>Optional</type>
          <declname>validate_on_init</declname>
          <defname>use_proxy</defname>
          <array>[bool]</array>
          <defval>None</defval>
        </param>
        <param>
          <type>Optional</type>
          <declname>use_proxy</declname>
          <defname>kw_only</defname>
          <array>[bool]</array>
          <defval>None</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>kw_only</declname>
          <defval>...</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="106" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="118" bodyend="120"/>
        <referencedby refid="namespacepydantic_1_1v1_1_1dataclasses_1aff60dbd965e47785922fb5047c1dbd18" compoundref="v1_2dataclasses_8py" startline="494" endline="501">pydantic.v1.dataclasses.make_dataclass_validator</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1aab4ac8bfb96ea43558abfd97058bf091" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type> &apos;<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a2d7331ed35801d80fad6ccee5cb2ef3b" kindref="member">DataclassClassOrWrapper</ref>&apos;</type>
        <definition> &apos;DataclassClassOrWrapper&apos; pydantic.v1.dataclasses.dataclass</definition>
        <argsstring>(Type[_T] _cls, *, bool init=True, bool repr=True, bool eq=True, bool order=False, bool unsafe_hash=False, bool frozen=False, Union[ConfigDict, Type[object], None] config=None, Optional[bool] validate_on_init=None, Optional[bool] use_proxy=None, bool kw_only=...)</argsstring>
        <name>dataclass</name>
        <qualifiedname>pydantic.v1.dataclasses.dataclass</qualifiedname>
        <param>
          <type>Type</type>
          <declname>_cls</declname>
          <array>[_T]</array>
        </param>
        <param>
          <type>*</type>
        </param>
        <param>
          <type>bool</type>
          <declname>init</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>repr</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>eq</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>order</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>unsafe_hash</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>frozen</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>Union</type>
          <defname>config</defname>
          <array>[ConfigDict, Type[object]</array>
        </param>
        <param>
          <type>None]</type>
          <declname>config</declname>
          <defname>validate_on_init</defname>
          <defval>None</defval>
        </param>
        <param>
          <type>Optional</type>
          <declname>validate_on_init</declname>
          <defname>use_proxy</defname>
          <array>[bool]</array>
          <defval>None</defval>
        </param>
        <param>
          <type>Optional</type>
          <declname>use_proxy</declname>
          <defname>kw_only</defname>
          <array>[bool]</array>
          <defval>None</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>kw_only</declname>
          <defval>...</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="123" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="136" bodyend="138"/>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1a3181beae334b08ad6af67dcbd5ddc341" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Callable[[Type[<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a4653ece05ae4bf55c30e16b8d3318cc7" kindref="member">_T</ref>]], &apos;<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a2d7331ed35801d80fad6ccee5cb2ef3b" kindref="member">DataclassClassOrWrapper</ref>&apos;]</type>
        <definition> Callable[[Type[_T]], &apos;DataclassClassOrWrapper&apos;] pydantic.v1.dataclasses.dataclass</definition>
        <argsstring>(*, bool init=True, bool repr=True, bool eq=True, bool order=False, bool unsafe_hash=False, bool frozen=False, Union[ConfigDict, Type[object], None] config=None, Optional[bool] validate_on_init=None, Optional[bool] use_proxy=None)</argsstring>
        <name>dataclass</name>
        <qualifiedname>pydantic.v1.dataclasses.dataclass</qualifiedname>
        <param>
          <type>*</type>
        </param>
        <param>
          <type>bool</type>
          <declname>init</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>repr</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>eq</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>order</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>unsafe_hash</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>frozen</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>Union</type>
          <defname>config</defname>
          <array>[ConfigDict, Type[object]</array>
        </param>
        <param>
          <type>None]</type>
          <declname>config</declname>
          <defname>validate_on_init</defname>
          <defval>None</defval>
        </param>
        <param>
          <type>Optional</type>
          <declname>validate_on_init</declname>
          <defname>use_proxy</defname>
          <array>[bool]</array>
          <defval>None</defval>
        </param>
        <param>
          <type>Optional</type>
          <declname>use_proxy</declname>
          <array>[bool]</array>
          <defval>None</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="143" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="154" bodyend="156"/>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1aa9054bde2190c141c8bb120a78b07fbc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type> &apos;<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a2d7331ed35801d80fad6ccee5cb2ef3b" kindref="member">DataclassClassOrWrapper</ref>&apos;</type>
        <definition> &apos;DataclassClassOrWrapper&apos; pydantic.v1.dataclasses.dataclass</definition>
        <argsstring>(Type[_T] _cls, *, bool init=True, bool repr=True, bool eq=True, bool order=False, bool unsafe_hash=False, bool frozen=False, Union[ConfigDict, Type[object], None] config=None, Optional[bool] validate_on_init=None, Optional[bool] use_proxy=None)</argsstring>
        <name>dataclass</name>
        <qualifiedname>pydantic.v1.dataclasses.dataclass</qualifiedname>
        <param>
          <type>Type</type>
          <declname>_cls</declname>
          <array>[_T]</array>
        </param>
        <param>
          <type>*</type>
        </param>
        <param>
          <type>bool</type>
          <declname>init</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>repr</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>eq</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>order</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>unsafe_hash</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>frozen</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>Union</type>
          <defname>config</defname>
          <array>[ConfigDict, Type[object]</array>
        </param>
        <param>
          <type>None]</type>
          <declname>config</declname>
          <defname>validate_on_init</defname>
          <defval>None</defval>
        </param>
        <param>
          <type>Optional</type>
          <declname>validate_on_init</declname>
          <defname>use_proxy</defname>
          <array>[bool]</array>
          <defval>None</defval>
        </param>
        <param>
          <type>Optional</type>
          <declname>use_proxy</declname>
          <array>[bool]</array>
          <defval>None</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="159" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="171" bodyend="175"/>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1a307a43741f722b02679555cfb38ac024" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Union[Callable[[Type[<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a4653ece05ae4bf55c30e16b8d3318cc7" kindref="member">_T</ref>]], &apos;<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a2d7331ed35801d80fad6ccee5cb2ef3b" kindref="member">DataclassClassOrWrapper</ref>&apos;], &apos;<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a2d7331ed35801d80fad6ccee5cb2ef3b" kindref="member">DataclassClassOrWrapper</ref>&apos;]</type>
        <definition> Union[Callable[[Type[_T]], &apos;DataclassClassOrWrapper&apos;], &apos;DataclassClassOrWrapper&apos;] pydantic.v1.dataclasses.dataclass</definition>
        <argsstring>(Optional[Type[_T]] _cls=None, *, bool init=True, bool repr=True, bool eq=True, bool order=False, bool unsafe_hash=False, bool frozen=False, Union[ConfigDict, Type[object], None] config=None, Optional[bool] validate_on_init=None, Optional[bool] use_proxy=None, bool kw_only=False)</argsstring>
        <name>dataclass</name>
        <qualifiedname>pydantic.v1.dataclasses.dataclass</qualifiedname>
        <param>
          <type>Optional]</type>
          <declname>_cls</declname>
          <array>[Type[_T]</array>
          <defval>None</defval>
        </param>
        <param>
          <type>*</type>
        </param>
        <param>
          <type>bool</type>
          <declname>init</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>repr</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>eq</declname>
          <defval>True</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>order</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>unsafe_hash</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>frozen</declname>
          <defval>False</defval>
        </param>
        <param>
          <type>Union</type>
          <defname>config</defname>
          <array>[ConfigDict, Type[object]</array>
        </param>
        <param>
          <type>None]</type>
          <declname>config</declname>
          <defname>validate_on_init</defname>
          <defval>None</defval>
        </param>
        <param>
          <type>Optional</type>
          <declname>validate_on_init</declname>
          <defname>use_proxy</defname>
          <array>[bool]</array>
          <defval>None</defval>
        </param>
        <param>
          <type>Optional</type>
          <declname>use_proxy</declname>
          <defname>kw_only</defname>
          <array>[bool]</array>
          <defval>None</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>kw_only</declname>
          <defval>False</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Like the python standard lib dataclasses but with type validation.
The result is either a pydantic dataclass that will validate input data
or a wrapper that will trigger validation around a stdlib dataclass
to avoid modifying it directly
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="176" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="189" bodyend="241"/>
        <references refid="namespacepydantic_1_1v1_1_1dataclasses_1a9fe01b53a420f186074a01ce85f86b24" compoundref="v1_2dataclasses_8py" startline="282" endline="362">pydantic.v1.dataclasses._add_pydantic_validation_attributes</references>
        <references refid="namespacepydantic_1_1v1_1_1dataclasses_1a173a8e57f5a45daa1187d6b43b3e6088" compoundref="v1_2dataclasses_8py" startline="465" endline="493">pydantic.v1.dataclasses.is_builtin_dataclass</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1aeec9b424f4cf93798250d46aa7ee0c58" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Generator[Type[ &apos;<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a455aa88f8b87f292307d5dc5f1008768" kindref="member">DataclassT</ref>&apos;], None, None]</type>
        <definition> Generator[Type[&apos;DataclassT&apos;], None, None] pydantic.v1.dataclasses.set_validation</definition>
        <argsstring>(Type[&apos;DataclassT&apos;] cls, bool value)</argsstring>
        <name>set_validation</name>
        <qualifiedname>pydantic.v1.dataclasses.set_validation</qualifiedname>
        <param>
          <type>Type</type>
          <declname>cls</declname>
          <array>[ &apos;DataclassT&apos;]</array>
        </param>
        <param>
          <type>bool</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="242" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="242" bodyend="250"/>
        <referencedby refid="namespacepydantic_1_1v1_1_1dataclasses_1a673075ca7ac6fbe808c73b49f29556e8" compoundref="v1_2dataclasses_8py" startline="367" endline="379">pydantic.v1.dataclasses._validate_dataclass</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1a9fe01b53a420f186074a01ce85f86b24" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>None</type>
        <definition> None pydantic.v1.dataclasses._add_pydantic_validation_attributes</definition>
        <argsstring>(Type[&apos;Dataclass&apos;] dc_cls, Type[BaseConfig] config, bool validate_on_init, str dc_cls_doc)</argsstring>
        <name>_add_pydantic_validation_attributes</name>
        <qualifiedname>pydantic.v1.dataclasses._add_pydantic_validation_attributes</qualifiedname>
        <param>
          <type>Type</type>
          <declname>dc_cls</declname>
          <array>[ &apos;Dataclass&apos;]</array>
        </param>
        <param>
          <type>Type</type>
          <declname>config</declname>
          <array>[BaseConfig]</array>
        </param>
        <param>
          <type>bool</type>
          <declname>validate_on_init</declname>
        </param>
        <param>
          <type>str</type>
          <declname>dc_cls_doc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>We need to replace the right method. If no `__post_init__` has been set in the stdlib dataclass
it won&apos;t even exist (code is generated on the fly by `dataclasses`)
By default, we run validation after `__init__` or `__post_init__` if defined
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="277" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="282" bodyend="362"/>
        <references refid="namespacepydantic_1_1v1_1_1dataclasses_1a598df5c71d81fccec63ac0b2c5c44ef0" compoundref="v1_2dataclasses_8py" startline="384" endline="418">pydantic.v1.dataclasses.create_pydantic_model_from_dataclass</references>
        <referencedby refid="namespacepydantic_1_1v1_1_1dataclasses_1a307a43741f722b02679555cfb38ac024" compoundref="v1_2dataclasses_8py" startline="189" endline="241">pydantic.v1.dataclasses.dataclass</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1a6b75b48b332af726282271e26c96a7af" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type> &apos;<ref refid="namespacepydantic_1_1v1_1_1networks_1a66d35608f82f7c35116efb2631dcbbcb" kindref="member">CallableGenerator</ref>&apos;</type>
        <definition> &apos;CallableGenerator&apos; pydantic.v1.dataclasses._get_validators</definition>
        <argsstring>(&apos;DataclassClassOrWrapper&apos; cls)</argsstring>
        <name>_get_validators</name>
        <qualifiedname>pydantic.v1.dataclasses._get_validators</qualifiedname>
        <param>
          <type>&apos;<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a2d7331ed35801d80fad6ccee5cb2ef3b" kindref="member">DataclassClassOrWrapper</ref>&apos;</type>
          <declname>cls</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="363" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="363" bodyend="366"/>
        <referencedby refid="namespacepydantic_1_1v1_1_1dataclasses_1aff60dbd965e47785922fb5047c1dbd18" compoundref="v1_2dataclasses_8py" startline="494" endline="501">pydantic.v1.dataclasses.make_dataclass_validator</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1a673075ca7ac6fbe808c73b49f29556e8" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type> &apos;<ref refid="namespacepydantic_1_1v1_1_1dataclasses_1a455aa88f8b87f292307d5dc5f1008768" kindref="member">DataclassT</ref>&apos;</type>
        <definition> &apos;DataclassT&apos; pydantic.v1.dataclasses._validate_dataclass</definition>
        <argsstring>(Type[&apos;DataclassT&apos;] cls, Any v)</argsstring>
        <name>_validate_dataclass</name>
        <qualifiedname>pydantic.v1.dataclasses._validate_dataclass</qualifiedname>
        <param>
          <type>Type</type>
          <declname>cls</declname>
          <array>[ &apos;DataclassT&apos;]</array>
        </param>
        <param>
          <type>Any</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="367" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="367" bodyend="379"/>
        <references refid="namespacepydantic_1_1v1_1_1dataclasses_1aeec9b424f4cf93798250d46aa7ee0c58" compoundref="v1_2dataclasses_8py" startline="242" endline="250">pydantic.v1.dataclasses.set_validation</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1a598df5c71d81fccec63ac0b2c5c44ef0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Type[ &apos;<ref refid="classpydantic_1_1v1_1_1main_1_1_base_model" kindref="compound">BaseModel</ref>&apos;]</type>
        <definition> Type[&apos;BaseModel&apos;] pydantic.v1.dataclasses.create_pydantic_model_from_dataclass</definition>
        <argsstring>(Type[&apos;Dataclass&apos;] dc_cls, Type[Any] config=BaseConfig, Optional[str] dc_cls_doc=None)</argsstring>
        <name>create_pydantic_model_from_dataclass</name>
        <qualifiedname>pydantic.v1.dataclasses.create_pydantic_model_from_dataclass</qualifiedname>
        <param>
          <type>Type</type>
          <declname>dc_cls</declname>
          <array>[ &apos;Dataclass&apos;]</array>
        </param>
        <param>
          <type>Type</type>
          <declname>config</declname>
          <array>[Any]</array>
          <defval><ref refid="classpydantic_1_1v1_1_1config_1_1_base_config" kindref="compound">BaseConfig</ref></defval>
        </param>
        <param>
          <type>Optional</type>
          <declname>dc_cls_doc</declname>
          <array>[str]</array>
          <defval>None</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="380" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="384" bodyend="418"/>
        <references refid="namespacepydantic_1_1v1_1_1main_1acfaa028a2cd6e589e43d01ccd92cd04c" compoundref="micro__gestion__objetos_2venv_2_lib_2site-packages_2pydantic_2v1_2main_8py" startline="938" endline="942">pydantic.v1.main.create_model</references>
        <referencedby refid="namespacepydantic_1_1v1_1_1dataclasses_1a9fe01b53a420f186074a01ce85f86b24" compoundref="v1_2dataclasses_8py" startline="282" endline="362">pydantic.v1.dataclasses._add_pydantic_validation_attributes</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1a86d97955cfaf1f5b3031f92376923878" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool pydantic::v1::dataclasses::_is_field_cached_property</definition>
        <argsstring>(&apos;Dataclass&apos; obj, str k)</argsstring>
        <name>_is_field_cached_property</name>
        <qualifiedname>pydantic.v1.dataclasses._is_field_cached_property</qualifiedname>
        <param>
          <type>&apos;<ref refid="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass" kindref="compound">Dataclass</ref>&apos;</type>
          <declname>obj</declname>
        </param>
        <param>
          <type>str</type>
          <declname>k</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="421" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="421" bodyend="423"/>
        <referencedby refid="namespacepydantic_1_1v1_1_1dataclasses_1acef977c097acf95eb5959b394a2416df" compoundref="v1_2dataclasses_8py" startline="430" endline="451">pydantic.v1.dataclasses._dataclass_validate_values</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1acef977c097acf95eb5959b394a2416df" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>None</type>
        <definition> None pydantic.v1.dataclasses._dataclass_validate_values</definition>
        <argsstring>(&apos;Dataclass&apos; self)</argsstring>
        <name>_dataclass_validate_values</name>
        <qualifiedname>pydantic.v1.dataclasses._dataclass_validate_values</qualifiedname>
        <param>
          <type>&apos;<ref refid="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass" kindref="compound">Dataclass</ref>&apos;</type>
          <declname>self</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="430" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="430" bodyend="451"/>
        <references refid="namespacepydantic_1_1v1_1_1dataclasses_1a86d97955cfaf1f5b3031f92376923878" compoundref="v1_2dataclasses_8py" startline="421" endline="423">pydantic.v1.dataclasses._is_field_cached_property</references>
        <references refid="namespacepydantic_1_1v1_1_1main_1a915c72e263391cc84fda79ac29b165f7" compoundref="micro__gestion__objetos_2venv_2_lib_2site-packages_2pydantic_2v1_2main_8py" startline="1038" endline="1114">pydantic.v1.main.validate_model</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1ae239cc33446fca66d8652bd634fdffbd" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>None</type>
        <definition> None pydantic.v1.dataclasses._dataclass_validate_assignment_setattr</definition>
        <argsstring>(&apos;Dataclass&apos; self, str name, Any value)</argsstring>
        <name>_dataclass_validate_assignment_setattr</name>
        <qualifiedname>pydantic.v1.dataclasses._dataclass_validate_assignment_setattr</qualifiedname>
        <param>
          <type>&apos;<ref refid="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass" kindref="compound">Dataclass</ref>&apos;</type>
          <declname>self</declname>
        </param>
        <param>
          <type>str</type>
          <declname>name</declname>
        </param>
        <param>
          <type>Any</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="452" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="452" bodyend="464"/>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1a173a8e57f5a45daa1187d6b43b3e6088" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition> bool pydantic.v1.dataclasses.is_builtin_dataclass</definition>
        <argsstring>(Type[Any] _cls)</argsstring>
        <name>is_builtin_dataclass</name>
        <qualifiedname>pydantic.v1.dataclasses.is_builtin_dataclass</qualifiedname>
        <param>
          <type>Type</type>
          <declname>_cls</declname>
          <array>[Any]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Whether a class is a stdlib dataclass
(useful to discriminated a pydantic dataclass that is actually a wrapper around a stdlib dataclass)

we check that
- `_cls` is a dataclass
- `_cls` is not a processed pydantic dataclass (with a basemodel attached)
- `_cls` is not a pydantic dataclass inheriting directly from a stdlib dataclass
e.g.
```
@dataclasses.dataclass
class A:
    x: int

@pydantic.dataclasses.dataclass
class B(A):
    y: int
```
In this case, when we first check `B`, we make an extra check and look at the annotations (&apos;y&apos;),
which won&apos;t be a superset of all the dataclass fields (only the stdlib fields i.e. &apos;x&apos;)
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="465" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="465" bodyend="493"/>
        <referencedby refid="namespacepydantic_1_1v1_1_1dataclasses_1a307a43741f722b02679555cfb38ac024" compoundref="v1_2dataclasses_8py" startline="189" endline="241">pydantic.v1.dataclasses.dataclass</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1v1_1_1dataclasses_1aff60dbd965e47785922fb5047c1dbd18" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type> &apos;<ref refid="namespacepydantic_1_1v1_1_1networks_1a66d35608f82f7c35116efb2631dcbbcb" kindref="member">CallableGenerator</ref>&apos;</type>
        <definition> &apos;CallableGenerator&apos; pydantic.v1.dataclasses.make_dataclass_validator</definition>
        <argsstring>(Type[&apos;Dataclass&apos;] dc_cls, Type[BaseConfig] config)</argsstring>
        <name>make_dataclass_validator</name>
        <qualifiedname>pydantic.v1.dataclasses.make_dataclass_validator</qualifiedname>
        <param>
          <type>Type</type>
          <declname>dc_cls</declname>
          <array>[ &apos;Dataclass&apos;]</array>
        </param>
        <param>
          <type>Type</type>
          <declname>config</declname>
          <array>[BaseConfig]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Create a pydantic.dataclass from a builtin dataclass to add type validation
and yield the validators
It retrieves the parameters of the dataclass and forwards them to the newly created dataclass
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="494" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" bodystart="494" bodyend="501"/>
        <references refid="namespacepydantic_1_1v1_1_1dataclasses_1a6b75b48b332af726282271e26c96a7af" compoundref="v1_2dataclasses_8py" startline="363" endline="366">pydantic.v1.dataclasses._get_validators</references>
        <references refid="namespacepydantic_1_1v1_1_1dataclasses_1abf55055adb13a482aaaf1f4301b44238" compoundref="v1_2dataclasses_8py" startline="118" endline="120">pydantic.v1.dataclasses.dataclass</references>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><verbatim>The main purpose is to enhance stdlib dataclasses by adding validation
A pydantic dataclass can be generated from scratch or from a stdlib one.

Behind the scene, a pydantic dataclass is just like a regular one on which we attach
a `BaseModel` and magic methods to trigger the validation of the data.
`__init__` and `__post_init__` are hence overridden and have extra logic to be
able to validate input data.

When a pydantic dataclass is generated from scratch, it&apos;s just a plain dataclass
with validation triggered at initialization

The tricky part if for stdlib dataclasses that are converted after into pydantic ones e.g.

```py
@dataclasses.dataclass
class M:
    x: int

ValidatedM = pydantic.dataclasses.dataclass(M)
```

We indeed still want to support equality, hashing, repr, ... as if it was the stdlib one!

```py
assert isinstance(ValidatedM(x=1), M)
assert ValidatedM(x=1) == M(x=1)
```

This means we **don&apos;t want to create a new dataclass that inherits from it**
The trick is to create a wrapper around `M` that will act as a proxy to trigger
validation without altering default `M` behaviour.
</verbatim> </para>
    </detaileddescription>
    <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/dataclasses.py" line="1" column="1"/>
  </compounddef>
</doxygen>

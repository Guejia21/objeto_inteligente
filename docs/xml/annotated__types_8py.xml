<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="es">
  <compounddef id="annotated__types_8py" kind="file" language="Python">
    <compoundname>annotated_types.py</compoundname>
    <innernamespace refid="namespacepydantic">pydantic</innernamespace>
    <innernamespace refid="namespacepydantic_1_1v1">pydantic::v1</innernamespace>
    <innernamespace refid="namespacepydantic_1_1v1_1_1annotated__types">pydantic::v1::annotated_types</innernamespace>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1" refid="namespacepydantic_1_1v1_1_1annotated__types" refkind="compound"><highlight class="keyword">import</highlight><highlight class="normal"><sp/>sys</highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>typing<sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>TYPE_CHECKING,<sp/>Any,<sp/>Dict,<sp/>FrozenSet,<sp/>NamedTuple,<sp/>Type</highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/><ref refid="namespacepydantic_1_1v1_1_1fields" kindref="compound">pydantic.v1.fields</ref><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>Required</highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/><ref refid="namespacepydantic_1_1v1_1_1main" kindref="compound">pydantic.v1.main</ref><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>BaseModel,<sp/>create_model</highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/><ref refid="namespacepydantic_1_1v1_1_1typing" kindref="compound">pydantic.v1.typing</ref><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>is_typeddict,<sp/>is_typeddict_special</highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>TYPE_CHECKING:</highlight></codeline>
<codeline lineno="9"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>typing_extensions<sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>TypedDict</highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>sys.version_info<sp/>&lt;<sp/>(3,<sp/>11):</highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight></codeline>
<codeline lineno="13" refid="namespacepydantic_1_1v1_1_1annotated__types_1a4176633db8947da743cc57a5c46e74fa" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacepydantic_1_1v1_1_1annotated__types_1a4176633db8947da743cc57a5c46e74fa" kindref="member">is_legacy_typeddict</ref>(typeddict_cls:<sp/>Type[</highlight><highlight class="stringliteral">&apos;TypedDict&apos;</highlight><highlight class="normal">])<sp/>-&gt;<sp/>bool:<sp/><sp/></highlight><highlight class="comment">#<sp/>type:<sp/>ignore[valid-type]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>is_typeddict(typeddict_cls)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>type(typeddict_cls).__module__<sp/>==<sp/></highlight><highlight class="stringliteral">&apos;typing&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight></codeline>
<codeline lineno="18" refid="namespacepydantic_1_1v1_1_1annotated__types_1a51cb3859cc73728ebee0b797c5fd4708" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacepydantic_1_1v1_1_1annotated__types_1a4176633db8947da743cc57a5c46e74fa" kindref="member">is_legacy_typeddict</ref>(_:<sp/>Any)<sp/>-&gt;<sp/>Any:</highlight></codeline>
<codeline lineno="19"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight></codeline>
<codeline lineno="22" refid="namespacepydantic_1_1v1_1_1annotated__types_1afea0d55727e0c52c22e8c003a35a0cba" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacepydantic_1_1v1_1_1annotated__types_1afea0d55727e0c52c22e8c003a35a0cba" kindref="member">create_model_from_typeddict</ref>(</highlight></codeline>
<codeline lineno="23"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Mypy<sp/>bug:<sp/>`Type[TypedDict]`<sp/>is<sp/>resolved<sp/>as<sp/>`Any`<sp/>https://github.com/python/mypy/issues/11030</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"><sp/><sp/><sp/><sp/>typeddict_cls:<sp/>Type[</highlight><highlight class="stringliteral">&apos;TypedDict&apos;</highlight><highlight class="normal">],<sp/><sp/></highlight><highlight class="comment">#<sp/>type:<sp/>ignore[valid-type]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"><sp/><sp/><sp/><sp/>**kwargs:<sp/>Any,</highlight></codeline>
<codeline lineno="26"><highlight class="normal">)<sp/>-&gt;<sp/>Type[</highlight><highlight class="stringliteral">&apos;BaseModel&apos;</highlight><highlight class="normal">]:</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="28"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Create<sp/>a<sp/>`BaseModel`<sp/>based<sp/>on<sp/>the<sp/>fields<sp/>of<sp/>a<sp/>`TypedDict`.</highlight></codeline>
<codeline lineno="29"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Since<sp/>`typing.TypedDict`<sp/>in<sp/>Python<sp/>3.8<sp/>does<sp/>not<sp/>store<sp/>runtime<sp/>information<sp/>about<sp/>optional<sp/>keys,</highlight></codeline>
<codeline lineno="30"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>we<sp/>raise<sp/>an<sp/>error<sp/>if<sp/>this<sp/>happens<sp/>(see<sp/>https://bugs.python.org/issue38834).</highlight></codeline>
<codeline lineno="31"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>&quot;&quot;&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/>field_definitions:<sp/>Dict[str,<sp/>Any]</highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Best<sp/>case<sp/>scenario:<sp/>with<sp/>python<sp/>3.9+<sp/>or<sp/>when<sp/>`TypedDict`<sp/>is<sp/>imported<sp/>from<sp/>`typing_extensions`</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>hasattr(typeddict_cls,<sp/></highlight><highlight class="stringliteral">&apos;__required_keys__&apos;</highlight><highlight class="normal">):</highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">raise</highlight><highlight class="normal"><sp/>TypeError(</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&apos;You<sp/>should<sp/>use<sp/>`typing_extensions.TypedDict`<sp/>instead<sp/>of<sp/>`typing.TypedDict`<sp/>with<sp/>Python<sp/>&lt;<sp/>3.9.2.<sp/>&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&apos;Without<sp/>it,<sp/>there<sp/>is<sp/>no<sp/>way<sp/>to<sp/>differentiate<sp/>required<sp/>and<sp/>optional<sp/>fields<sp/>when<sp/>subclassed.&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline lineno="40"><highlight class="normal"></highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/><ref refid="namespacepydantic_1_1v1_1_1annotated__types_1a4176633db8947da743cc57a5c46e74fa" kindref="member">is_legacy_typeddict</ref>(typeddict_cls)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>any(</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>is_typeddict_special(t)<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>t<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>typeddict_cls.__annotations__.values()</highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/>):</highlight></codeline>
<codeline lineno="44"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">raise</highlight><highlight class="normal"><sp/>TypeError(</highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&apos;You<sp/>should<sp/>use<sp/>`typing_extensions.TypedDict`<sp/>instead<sp/>of<sp/>`typing.TypedDict`<sp/>with<sp/>Python<sp/>&lt;<sp/>3.11.<sp/>&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&apos;Without<sp/>it,<sp/>there<sp/>is<sp/>no<sp/>way<sp/>to<sp/>reflect<sp/>Required/NotRequired<sp/>keys.&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline lineno="48"><highlight class="normal"></highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/><sp/><sp/>required_keys:<sp/>FrozenSet[str]<sp/>=<sp/>typeddict_cls.__required_keys__<sp/><sp/></highlight><highlight class="comment">#<sp/>type:<sp/>ignore[attr-defined]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/>field_definitions<sp/>=<sp/>{</highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>field_name:<sp/>(field_type,<sp/>Required<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>field_name<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>required_keys<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>field_name,<sp/>field_type<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>typeddict_cls.__annotations__.items()</highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="54"><highlight class="normal"></highlight></codeline>
<codeline lineno="55"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespacepydantic_1_1v1_1_1main_1acfaa028a2cd6e589e43d01ccd92cd04c" kindref="member">create_model</ref>(typeddict_cls.__name__,<sp/>**kwargs,<sp/>**field_definitions)</highlight></codeline>
<codeline lineno="56"><highlight class="normal"></highlight></codeline>
<codeline lineno="57"><highlight class="normal"></highlight></codeline>
<codeline lineno="58" refid="namespacepydantic_1_1v1_1_1annotated__types_1a0e7743de79ec55e7ca6413f639d74561" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacepydantic_1_1v1_1_1annotated__types_1a0e7743de79ec55e7ca6413f639d74561" kindref="member">create_model_from_namedtuple</ref>(namedtuple_cls:<sp/>Type[</highlight><highlight class="stringliteral">&apos;NamedTuple&apos;</highlight><highlight class="normal">],<sp/>**kwargs:<sp/>Any)<sp/>-&gt;<sp/>Type[</highlight><highlight class="stringliteral">&apos;BaseModel&apos;</highlight><highlight class="normal">]:</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="60"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Create<sp/>a<sp/>`BaseModel`<sp/>based<sp/>on<sp/>the<sp/>fields<sp/>of<sp/>a<sp/>named<sp/>tuple.</highlight></codeline>
<codeline lineno="61"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>A<sp/>named<sp/>tuple<sp/>can<sp/>be<sp/>created<sp/>with<sp/>`typing.NamedTuple`<sp/>and<sp/>declared<sp/>annotations</highlight></codeline>
<codeline lineno="62"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>but<sp/>also<sp/>with<sp/>`collections.namedtuple`,<sp/>in<sp/>this<sp/>case<sp/>we<sp/>consider<sp/>all<sp/>fields</highlight></codeline>
<codeline lineno="63"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>to<sp/>have<sp/>type<sp/>`Any`.</highlight></codeline>
<codeline lineno="64"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>&quot;&quot;&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>With<sp/>python<sp/>3.10+,<sp/>`__annotations__`<sp/>always<sp/>exists<sp/>but<sp/>can<sp/>be<sp/>empty<sp/>hence<sp/>the<sp/>`getattr...<sp/>or...`<sp/>logic</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/>namedtuple_annotations:<sp/>Dict[str,<sp/>Type[Any]]<sp/>=<sp/>getattr(namedtuple_cls,<sp/></highlight><highlight class="stringliteral">&apos;__annotations__&apos;</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal">)<sp/></highlight><highlight class="keywordflow">or</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>k:<sp/>Any<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>k<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>namedtuple_cls._fields</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/>field_definitions:<sp/>Dict[str,<sp/>Any]<sp/>=<sp/>{</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>field_name:<sp/>(field_type,<sp/>Required)<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>field_name,<sp/>field_type<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>namedtuple_annotations.items()</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespacepydantic_1_1v1_1_1main_1acfaa028a2cd6e589e43d01ccd92cd04c" kindref="member">create_model</ref>(namedtuple_cls.__name__,<sp/>**kwargs,<sp/>**field_definitions)</highlight></codeline>
    </programlisting>
    <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/v1/annotated_types.py"/>
  </compounddef>
</doxygen>

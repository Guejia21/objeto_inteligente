<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="es">
  <compounddef id="namespacepydantic_1_1__internal_1_1__dataclasses" kind="namespace" language="Python">
    <compoundname>pydantic::_internal::_dataclasses</compoundname>
    <innerclass refid="classpydantic_1_1__internal_1_1__dataclasses_1_1_pydantic_dataclass" prot="public">pydantic::_internal::_dataclasses::PydanticDataclass</innerclass>
    <sectiondef kind="var">
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__dataclasses_1a0bbfc838259f236ad6761daa81835363" prot="public" static="no" mutable="no">
        <type>TypeAlias</type>
        <definition>TypeAlias pydantic::_internal::_dataclasses.DcFields</definition>
        <argsstring></argsstring>
        <name>DcFields</name>
        <qualifiedname>pydantic._internal._dataclasses.DcFields</qualifiedname>
        <initializer>=  dict[str, dataclasses.Field[Any]]</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" line="226" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" bodystart="226" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__dataclasses_1a77eed25ad21231d8c11cbad890b97af3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>None</type>
        <definition> None pydantic._internal._dataclasses.set_dataclass_fields</definition>
        <argsstring>(type[StandardDataclass] cls, _config.ConfigWrapper config_wrapper, NsResolver|None ns_resolver=None)</argsstring>
        <name>set_dataclass_fields</name>
        <qualifiedname>pydantic._internal._dataclasses.set_dataclass_fields</qualifiedname>
        <param>
          <type>type</type>
          <declname>cls</declname>
          <array>[StandardDataclass]</array>
        </param>
        <param>
          <type><ref refid="classpydantic_1_1__internal_1_1__config_1_1_config_wrapper" kindref="compound">_config.ConfigWrapper</ref></type>
          <declname>config_wrapper</declname>
        </param>
        <param>
          <type><ref refid="classpydantic_1_1__internal_1_1__namespace__utils_1_1_ns_resolver" kindref="compound">NsResolver</ref>|None</type>
          <declname>ns_resolver</declname>
          <defval>None</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Collect and set `cls.__pydantic_fields__`.

Args:
    cls: The class.
    config_wrapper: The config wrapper instance.
    ns_resolver: Namespace resolver to use when getting dataclass annotations.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" line="65" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" bodystart="69" bodyend="84"/>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__dataclasses_1a266847a42d1b54567f4b4359c9fb26ed" compoundref="__dataclasses_8py" startline="92" endline="192">pydantic._internal._dataclasses.complete_dataclass</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__dataclasses_1a266847a42d1b54567f4b4359c9fb26ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition> bool pydantic._internal._dataclasses.complete_dataclass</definition>
        <argsstring>(type[Any] cls, _config.ConfigWrapper config_wrapper, *, bool raise_errors=True, NsResolver|None ns_resolver=None, bool _force_build=False)</argsstring>
        <name>complete_dataclass</name>
        <qualifiedname>pydantic._internal._dataclasses.complete_dataclass</qualifiedname>
        <param>
          <type>type</type>
          <declname>cls</declname>
          <array>[Any]</array>
        </param>
        <param>
          <type><ref refid="classpydantic_1_1__internal_1_1__config_1_1_config_wrapper" kindref="compound">_config.ConfigWrapper</ref></type>
          <declname>config_wrapper</declname>
        </param>
        <param>
          <type>*</type>
        </param>
        <param>
          <type>bool</type>
          <declname>raise_errors</declname>
          <defval>True</defval>
        </param>
        <param>
          <type><ref refid="classpydantic_1_1__internal_1_1__namespace__utils_1_1_ns_resolver" kindref="compound">NsResolver</ref>|None</type>
          <declname>ns_resolver</declname>
          <defval>None</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>_force_build</declname>
          <defval>False</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Finish building a pydantic dataclass.

This logic is called on a class which has already been wrapped in `dataclasses.dataclass()`.

This is somewhat analogous to `pydantic._internal._model_construction.complete_model_class`.

Args:
    cls: The class.
    config_wrapper: The config wrapper instance.
    raise_errors: Whether to raise errors, defaults to `True`.
    ns_resolver: The namespace resolver instance to use when collecting dataclass fields
        and during schema building.
    _force_build: Whether to force building the dataclass, no matter if
        [`defer_build`][pydantic.config.ConfigDict.defer_build] is set.

Returns:
    `True` if building a pydantic dataclass is successfully completed, `False` otherwise.

Raises:
    PydanticUndefinedAnnotation: If `raise_error` is `True` and there is an undefined annotations.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" line="85" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" bodystart="92" bodyend="192"/>
        <references refid="namespacepydantic_1_1__internal_1_1__dataclasses_1a77eed25ad21231d8c11cbad890b97af3" compoundref="__dataclasses_8py" startline="69" endline="84">pydantic._internal._dataclasses.set_dataclass_fields</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__dataclasses_1abe60dd98b99019ccb86633f79fe59bcf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TypeIs[type[StandardDataclass]]</type>
        <definition> TypeIs[type[StandardDataclass]] pydantic._internal._dataclasses.is_stdlib_dataclass</definition>
        <argsstring>(type[Any] cls)</argsstring>
        <name>is_stdlib_dataclass</name>
        <qualifiedname>pydantic._internal._dataclasses.is_stdlib_dataclass</qualifiedname>
        <param>
          <type>type</type>
          <declname>cls</declname>
          <array>[Any]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Returns `True` if the class is a stdlib dataclass and *not* a Pydantic dataclass.

Unlike the stdlib `dataclasses.is_dataclass()` function, this does *not* include subclasses
of a dataclass that are themselves not dataclasses.

Args:
    cls: The class.

Returns:
    `True` if the class is a stdlib dataclass, `False` otherwise.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" line="193" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" bodystart="193" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__dataclasses_1ade5001444c71ee8ffa4dbfc3ee7b53e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>dataclasses.Field[Any]</type>
        <definition> dataclasses.Field[Any] pydantic._internal._dataclasses.as_dataclass_field</definition>
        <argsstring>(FieldInfo pydantic_field)</argsstring>
        <name>as_dataclass_field</name>
        <qualifiedname>pydantic._internal._dataclasses.as_dataclass_field</qualifiedname>
        <param>
          <type><ref refid="classpydantic_1_1fields_1_1_field_info" kindref="compound">FieldInfo</ref></type>
          <declname>pydantic_field</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" line="208" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" bodystart="208" bodyend="225"/>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__dataclasses_1aba47473eb4d2b0ab0a942e0cc308dc2e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Generator[None]</type>
        <definition> Generator[None] pydantic._internal._dataclasses.patch_base_fields</definition>
        <argsstring>(type[Any] cls)</argsstring>
        <name>patch_base_fields</name>
        <qualifiedname>pydantic._internal._dataclasses.patch_base_fields</qualifiedname>
        <param>
          <type>type</type>
          <declname>cls</declname>
          <array>[Any]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Temporarily patch the stdlib dataclasses bases of `cls` if the Pydantic `Field()` function is used.

When creating a Pydantic dataclass, it is possible to inherit from stdlib dataclasses, where
the Pydantic `Field()` function is used. To create this Pydantic dataclass, we first apply
the stdlib `@dataclass` decorator on it. During the construction of the stdlib dataclass,
the `kw_only` and `repr` field arguments need to be understood by the stdlib *during* the
dataclass construction. To do so, we temporarily patch the fields dictionary of the affected
bases.

For instance, with the following example:

```python {test=&quot;skip&quot; lint=&quot;skip&quot;}
import dataclasses as stdlib_dc

import pydantic
import pydantic.dataclasses as pydantic_dc

@stdlib_dc.dataclass
class A:
    a: int = pydantic.Field(repr=False)

# Notice that the `repr` attribute of the dataclass field is `True`:
A.__dataclass_fields__[&apos;a&apos;]
#&gt; dataclass.Field(default=FieldInfo(repr=False), repr=True, ...)

@pydantic_dc.dataclass
class B(A):
    b: int = pydantic.Field(repr=False)
```

When passing `B` to the stdlib `@dataclass` decorator, it will look for fields in the parent classes
and reuse them directly. When this context manager is active, `A` will be temporarily patched to be
equivalent to:

```python {test=&quot;skip&quot; lint=&quot;skip&quot;}
@stdlib_dc.dataclass
class A:
    a: int = stdlib_dc.field(default=Field(repr=False), repr=False)
```

!!! note
    This is only applied to the bases of `cls`, and not `cls` itself. The reason is that the Pydantic
    dataclass decorator &quot;owns&quot; `cls` (in the previous example, `B`). As such, we instead modify the fields
    directly (in the previous example, we simply do `setattr(B, &apos;b&apos;, as_dataclass_field(pydantic_field))`).

!!! note
    This approach is far from ideal, and can probably be the source of unwanted side effects/race conditions.
    The previous implemented approach was mutating the `__annotations__` dict of `cls`, which is no longer a
    safe operation in Python 3.14+, and resulted in unexpected behavior with field ordering anyway.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" line="230" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" bodystart="230" bodyend="316"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><verbatim>Private logic for creating pydantic dataclasses.</verbatim> </para>
    </detaileddescription>
    <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_dataclasses.py" line="1" column="1"/>
  </compounddef>
</doxygen>

<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="es">
  <compounddef id="namespacepydantic_1_1__internal_1_1__generics" kind="namespace" language="Python">
    <compoundname>pydantic::_internal::_generics</compoundname>
    <innerclass refid="classpydantic_1_1__internal_1_1__generics_1_1_limited_dict" prot="public">pydantic::_internal::_generics::LimitedDict</innerclass>
    <innerclass refid="classpydantic_1_1__internal_1_1__generics_1_1_deep_chain_map" prot="public">pydantic::_internal::_generics::DeepChainMap</innerclass>
    <innerclass refid="classpydantic_1_1__internal_1_1__generics_1_1_pydantic_generic_metadata" prot="public">pydantic::_internal::_generics::PydanticGenericMetadata</innerclass>
    <sectiondef kind="var">
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__generics_1af66dce654d9513143523a13ddec1ff64" prot="public" static="no" mutable="no">
        <type></type>
        <definition>pydantic::_internal::_generics.GenericTypesCacheKey</definition>
        <argsstring></argsstring>
        <name>GenericTypesCacheKey</name>
        <qualifiedname>pydantic._internal._generics.GenericTypesCacheKey</qualifiedname>
        <initializer>=  tuple[Any, Any, tuple[Any, ...]]</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="29" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="29" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__generics_1a9105fc49941fc60b0585824ef933bd48" prot="public" static="no" mutable="no">
        <type></type>
        <definition>pydantic::_internal::_generics.KT</definition>
        <argsstring></argsstring>
        <name>KT</name>
        <qualifiedname>pydantic._internal._generics.KT</qualifiedname>
        <initializer>=  TypeVar(&apos;KT&apos;)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="37" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="37" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__generics_1a041e256fadbac3133f8d1c4dab1df1f2" prot="public" static="no" mutable="no">
        <type></type>
        <definition>pydantic::_internal::_generics.VT</definition>
        <argsstring></argsstring>
        <name>VT</name>
        <qualifiedname>pydantic._internal._generics.VT</qualifiedname>
        <initializer>=  TypeVar(&apos;VT&apos;)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="38" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__generics_1ab0a4726777265f7ae662e5519a732e5b" prot="protected" static="no" mutable="no">
        <type>int</type>
        <definition>int pydantic::_internal::_generics._LIMITED_DICT_SIZE</definition>
        <argsstring></argsstring>
        <name>_LIMITED_DICT_SIZE</name>
        <qualifiedname>pydantic._internal._generics._LIMITED_DICT_SIZE</qualifiedname>
        <initializer>=  100</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="39" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__generics_1a39a759bcb29ba97f166450d257693259" prot="public" static="no" mutable="no">
        <type></type>
        <definition>pydantic::_internal::_generics.GenericTypesCache</definition>
        <argsstring></argsstring>
        <name>GenericTypesCache</name>
        <qualifiedname>pydantic._internal._generics.GenericTypesCache</qualifiedname>
        <initializer>=  WeakValueDictionary[<ref refid="namespacepydantic_1_1__internal_1_1__generics_1af66dce654d9513143523a13ddec1ff64" kindref="member">GenericTypesCacheKey</ref>, &apos;type[<ref refid="classpydantic_1_1main_1_1_base_model" kindref="compound">BaseModel</ref>]&apos;]</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="58" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="58" bodyend="-1"/>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1a3c9314192feecb986c1a784369b212fa" compoundref="__generics_8py" startline="438" endline="461">pydantic._internal._generics.get_cached_generic_type_early</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1a1c055e35886a98db1334e04fc60f8be0" compoundref="__generics_8py" startline="464" endline="477">pydantic._internal._generics.get_cached_generic_type_late</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1ac46c5b5c5c2d0a221f8cda82b25ae9c0" compoundref="__generics_8py" startline="484" endline="500">pydantic._internal._generics.set_cached_generic_type</referencedby>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__generics_1ac482f3da5f4edd52b0b458c5a729c253" prot="public" static="no" mutable="no">
        <type>dict</type>
        <definition>dict pydantic::_internal::_generics.DictValues</definition>
        <argsstring></argsstring>
        <name>DictValues</name>
        <qualifiedname>pydantic._internal._generics.DictValues</qualifiedname>
        <initializer>=  {}.values().__class__</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="174" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="174" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacepydantic_1_1__internal_1_1__generics_1a852f427cbedb8cfd7cf488f2ffef9c18" prot="protected" static="no" mutable="no">
        <type>ContextVar</type>
        <definition>ContextVar pydantic::_internal::_generics._generic_recursion_cache</definition>
        <argsstring></argsstring>
        <name>_generic_recursion_cache</name>
        <qualifiedname>pydantic._internal._generics._generic_recursion_cache</qualifiedname>
        <initializer>=  ContextVar(&apos;_generic_recursion_cache&apos;, default=None)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="395" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="395" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1afcded858103d896453101e13b29d2a9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>type[<ref refid="classpydantic_1_1main_1_1_base_model" kindref="compound">BaseModel</ref>]</type>
        <definition> type[BaseModel] pydantic._internal._generics.create_generic_submodel</definition>
        <argsstring>(str model_name, type[BaseModel] origin, tuple[Any,...] args, tuple[Any,...] params)</argsstring>
        <name>create_generic_submodel</name>
        <qualifiedname>pydantic._internal._generics.create_generic_submodel</qualifiedname>
        <param>
          <type>str</type>
          <declname>model_name</declname>
        </param>
        <param>
          <type>type</type>
          <declname>origin</declname>
          <array>[BaseModel]</array>
        </param>
        <param>
          <type>tuple</type>
          <declname>args</declname>
          <array>[Any,...]</array>
        </param>
        <param>
          <type>tuple</type>
          <declname>params</declname>
          <array>[Any,...]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Dynamically create a submodel of a provided (generic) BaseModel.

This is used when producing concrete parametrizations of generic models. This function
only *creates* the new subclass; the schema/validators/serialization must be updated to
reflect a concrete parametrization elsewhere.

Args:
    model_name: The name of the newly created model.
    origin: The base class for the new model to inherit from.
    args: A tuple of generic metadata arguments.
    params: A tuple of generic metadata parameters.

Returns:
    The created submodel.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="105" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="107" bodyend="151"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a79b21e519e79b1218b1f3d652fa33b1d" compoundref="__generics_8py" startline="152" endline="173">pydantic._internal._generics._get_caller_frame_info</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1a79b21e519e79b1218b1f3d652fa33b1d" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>tuple[str|None, bool]</type>
        <definition> tuple[str | None, bool] pydantic._internal._generics._get_caller_frame_info</definition>
        <argsstring>(int depth=2)</argsstring>
        <name>_get_caller_frame_info</name>
        <qualifiedname>pydantic._internal._generics._get_caller_frame_info</qualifiedname>
        <param>
          <type>int</type>
          <declname>depth</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Used inside a function to check whether it was called globally.

Args:
    depth: The depth to get the frame.

Returns:
    A tuple contains `module_name` and `called_globally`.

Raises:
    RuntimeError: If the function is not called inside a function.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="152" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="152" bodyend="173"/>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1afcded858103d896453101e13b29d2a9b" compoundref="__generics_8py" startline="107" endline="151">pydantic._internal._generics.create_generic_submodel</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1a91e72b4bc6889cef434bb6ffd83d61bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Iterator[TypeVar]</type>
        <definition> Iterator[TypeVar] pydantic._internal._generics.iter_contained_typevars</definition>
        <argsstring>(Any v)</argsstring>
        <name>iter_contained_typevars</name>
        <qualifiedname>pydantic._internal._generics.iter_contained_typevars</qualifiedname>
        <param>
          <type>Any</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Recursively iterate through all subtypes and type args of `v` and yield any typevars that are found.

This is inspired as an alternative to directly accessing the `__parameters__` attribute of a GenericAlias,
since __parameters__ of (nested) generic BaseModel subclasses won&apos;t show up in that list.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="177" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="177" bodyend="195"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a29a07a03dba4ccf370007eb6718cd7b9" compoundref="__generics_8py" startline="196" endline="202">pydantic._internal._generics.get_args</references>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a91e72b4bc6889cef434bb6ffd83d61bc" compoundref="__generics_8py" startline="177" endline="195">pydantic._internal._generics.iter_contained_typevars</references>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1af8dab9794ade8386bed3975ec7a1c3f8" compoundref="__generics_8py" startline="227" endline="244">pydantic._internal._generics.get_model_typevars_map</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1a91e72b4bc6889cef434bb6ffd83d61bc" compoundref="__generics_8py" startline="177" endline="195">pydantic._internal._generics.iter_contained_typevars</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1a29a07a03dba4ccf370007eb6718cd7b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Any</type>
        <definition> Any pydantic._internal._generics.get_args</definition>
        <argsstring>(Any v)</argsstring>
        <name>get_args</name>
        <qualifiedname>pydantic._internal._generics.get_args</qualifiedname>
        <param>
          <type>Any</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="196" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="196" bodyend="202"/>
        <references refid="namespacetyping__extensions_1abe2888fbec369aced9e2585a905caa7f" compoundref="micro__gestion__objetos_2venv_2_lib_2site-packages_2typing__extensions_8py" startline="1578">typing_extensions.get_args</references>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1ad1b2be56fbba991bdca0c593c464a6c2" compoundref="__generics_8py" startline="501" endline="521">pydantic._internal._generics._union_orderings_key</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1a91e72b4bc6889cef434bb6ffd83d61bc" compoundref="__generics_8py" startline="177" endline="195">pydantic._internal._generics.iter_contained_typevars</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1abf393e8a431474b872c9096a8e99fadd" compoundref="__generics_8py" startline="245" endline="341">pydantic._internal._generics.replace_types</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1a71145b763a2bc45e77b2f646d9d365b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Any</type>
        <definition> Any pydantic._internal._generics.get_origin</definition>
        <argsstring>(Any v)</argsstring>
        <name>get_origin</name>
        <qualifiedname>pydantic._internal._generics.get_origin</qualifiedname>
        <param>
          <type>Any</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="203" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="203" bodyend="209"/>
        <references refid="namespacetyping__extensions_1a4bbba25af711824493b09a427463198d" compoundref="micro__gestion__objetos_2venv_2_lib_2site-packages_2typing__extensions_8py" startline="1577">typing_extensions.get_origin</references>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1ae5f63b9cae8e839cd0f0237583dd02c8" compoundref="__generics_8py" startline="210" endline="226">pydantic._internal._generics.get_standard_typevars_map</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1abf393e8a431474b872c9096a8e99fadd" compoundref="__generics_8py" startline="245" endline="341">pydantic._internal._generics.replace_types</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1ae5f63b9cae8e839cd0f0237583dd02c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>dict[TypeVar, Any]|None</type>
        <definition> dict[TypeVar, Any] | None pydantic._internal._generics.get_standard_typevars_map</definition>
        <argsstring>(Any cls)</argsstring>
        <name>get_standard_typevars_map</name>
        <qualifiedname>pydantic._internal._generics.get_standard_typevars_map</qualifiedname>
        <param>
          <type>Any</type>
          <declname>cls</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Package a generic type&apos;s typevars and parametrization (if present) into a dictionary compatible with the
`replace_types` function. Specifically, this works with standard typing generics and typing._GenericAlias.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="210" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="210" bodyend="226"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a71145b763a2bc45e77b2f646d9d365b5" compoundref="__generics_8py" startline="203" endline="209">pydantic._internal._generics.get_origin</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1af8dab9794ade8386bed3975ec7a1c3f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>dict[TypeVar, Any]</type>
        <definition> dict[TypeVar, Any] pydantic._internal._generics.get_model_typevars_map</definition>
        <argsstring>(type[BaseModel] cls)</argsstring>
        <name>get_model_typevars_map</name>
        <qualifiedname>pydantic._internal._generics.get_model_typevars_map</qualifiedname>
        <param>
          <type>type</type>
          <declname>cls</declname>
          <array>[BaseModel]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Package a generic BaseModel&apos;s typevars and concrete parametrization (if present) into a dictionary compatible
with the `replace_types` function.

Since BaseModel.__class_getitem__ does not produce a typing._GenericAlias, and the BaseModel generic info is
stored in the __pydantic_generic_metadata__ attribute, we need special handling here.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="227" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="227" bodyend="244"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a91e72b4bc6889cef434bb6ffd83d61bc" compoundref="__generics_8py" startline="177" endline="195">pydantic._internal._generics.iter_contained_typevars</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1abf393e8a431474b872c9096a8e99fadd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Any</type>
        <definition> Any pydantic._internal._generics.replace_types</definition>
        <argsstring>(Any type_, Mapping[TypeVar, Any]|None type_map)</argsstring>
        <name>replace_types</name>
        <qualifiedname>pydantic._internal._generics.replace_types</qualifiedname>
        <param>
          <type>Any</type>
          <declname>type_</declname>
        </param>
        <param>
          <type>Mapping|None</type>
          <declname>type_map</declname>
          <array>[TypeVar, Any]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Return type with all occurrences of `type_map` keys recursively replaced with their values.

Args:
    type_: The class or generic alias.
    type_map: Mapping from `TypeVar` instance to concrete types.

Returns:
    A new type representing the basic structure of `type_` with all
    `typevar_map` keys recursively replaced.

Example:
    ```python
    from typing import Union

    from pydantic._internal._generics import replace_types

    replace_types(tuple[str, Union[list[str], float]], {str: int})
    #&gt; tuple[int, Union[list[int], float]]
    ```
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="245" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="245" bodyend="341"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a29a07a03dba4ccf370007eb6718cd7b9" compoundref="__generics_8py" startline="196" endline="202">pydantic._internal._generics.get_args</references>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a71145b763a2bc45e77b2f646d9d365b5" compoundref="__generics_8py" startline="203" endline="209">pydantic._internal._generics.get_origin</references>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1abf393e8a431474b872c9096a8e99fadd" compoundref="__generics_8py" startline="245" endline="341">pydantic._internal._generics.replace_types</references>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1a988383c2fcc5e45381e7a3246650d212" compoundref="__generics_8py" startline="342" endline="394">pydantic._internal._generics.map_generic_model_arguments</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1abf393e8a431474b872c9096a8e99fadd" compoundref="__generics_8py" startline="245" endline="341">pydantic._internal._generics.replace_types</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1a988383c2fcc5e45381e7a3246650d212" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>dict[TypeVar, Any]</type>
        <definition> dict[TypeVar, Any] pydantic._internal._generics.map_generic_model_arguments</definition>
        <argsstring>(type[BaseModel] cls, tuple[Any,...] args)</argsstring>
        <name>map_generic_model_arguments</name>
        <qualifiedname>pydantic._internal._generics.map_generic_model_arguments</qualifiedname>
        <param>
          <type>type</type>
          <declname>cls</declname>
          <array>[BaseModel]</array>
        </param>
        <param>
          <type>tuple</type>
          <declname>args</declname>
          <array>[Any,...]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Return a mapping between the parameters of a generic model and the provided arguments during parameterization.

Raises:
    TypeError: If the number of arguments does not match the parameters (i.e. if providing too few or too many arguments).

Example:
    ```python {test=&quot;skip&quot; lint=&quot;skip&quot;}
    class Model[T, U, V = int](BaseModel): ...

    map_generic_model_arguments(Model, (str, bytes))
    #&gt; {T: str, U: bytes, V: int}

    map_generic_model_arguments(Model, (str,))
    #&gt; TypeError: Too few arguments for &lt;class &apos;__main__.Model&apos;&gt;; actual 1, expected at least 2

    map_generic_model_arguments(Model, (str, bytes, int, complex))
    #&gt; TypeError: Too many arguments for &lt;class &apos;__main__.Model&apos;&gt;; actual 4, expected 3
    ```

Note:
    This function is analogous to the private `typing._check_generic_specialization` function.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="342" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="342" bodyend="394"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1abf393e8a431474b872c9096a8e99fadd" compoundref="__generics_8py" startline="245" endline="341">pydantic._internal._generics.replace_types</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1a05b120c91cf4df0a83a1cea779288b53" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Iterator[<ref refid="classpydantic_1_1__internal_1_1__forward__ref_1_1_pydantic_recursive_ref" kindref="compound">PydanticRecursiveRef</ref>|None]</type>
        <definition> Iterator[PydanticRecursiveRef | None] pydantic._internal._generics.generic_recursion_self_type</definition>
        <argsstring>(type[BaseModel] origin, tuple[Any,...] args)</argsstring>
        <name>generic_recursion_self_type</name>
        <qualifiedname>pydantic._internal._generics.generic_recursion_self_type</qualifiedname>
        <param>
          <type>type</type>
          <declname>origin</declname>
          <array>[BaseModel]</array>
        </param>
        <param>
          <type>tuple</type>
          <declname>args</declname>
          <array>[Any,...]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>This contextmanager should be placed around the recursive calls used to build a generic type,
and accept as arguments the generic origin type and the type arguments being passed to it.

If the same origin and arguments are observed twice, it implies that a self-reference placeholder
can be used while building the core schema, and will produce a schema_ref that will be valid in the
final parent schema.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="399" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="401" bodyend="429"/>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1a58e6abceadaad8d39b24555f71afe7d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>set[str]</type>
        <definition> set[str] pydantic._internal._generics.recursively_defined_type_refs</definition>
        <argsstring>()</argsstring>
        <name>recursively_defined_type_refs</name>
        <qualifiedname>pydantic._internal._generics.recursively_defined_type_refs</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="430" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="430" bodyend="437"/>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1a3c9314192feecb986c1a784369b212fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>type[<ref refid="classpydantic_1_1main_1_1_base_model" kindref="compound">BaseModel</ref>]|None</type>
        <definition> type[BaseModel] | None pydantic._internal._generics.get_cached_generic_type_early</definition>
        <argsstring>(type[BaseModel] parent, Any typevar_values)</argsstring>
        <name>get_cached_generic_type_early</name>
        <qualifiedname>pydantic._internal._generics.get_cached_generic_type_early</qualifiedname>
        <param>
          <type>type</type>
          <declname>parent</declname>
          <array>[BaseModel]</array>
        </param>
        <param>
          <type>Any</type>
          <declname>typevar_values</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>The use of a two-stage cache lookup approach was necessary to have the highest performance possible for
repeated calls to `__class_getitem__` on generic types (which may happen in tighter loops during runtime),
while still ensuring that certain alternative parametrizations ultimately resolve to the same type.

As a concrete example, this approach was necessary to make Model[List[T]][int] equal to Model[List[int]].
The approach could be modified to not use two different cache keys at different points, but the
_early_cache_key is optimized to be as quick to compute as possible (for repeated-access speed), and the
_late_cache_key is optimized to be as &quot;correct&quot; as possible, so that two types that will ultimately be the
same after resolving the type arguments will always produce cache hits.

If we wanted to move to only using a single cache key per type, we would either need to always use the
slower/more computationally intensive logic associated with _late_cache_key, or would need to accept
that Model[List[T]][int] is a different type than Model[List[T]][int]. Because we rely on subclass relationships
during validation, I think it is worthwhile to ensure that types that are functionally equivalent are actually
equal.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="438" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="438" bodyend="461"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a0b982a936af6d27a669a64ff44d55fc4" compoundref="__generics_8py" startline="522" endline="533">pydantic._internal._generics._early_cache_key</references>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a39a759bcb29ba97f166450d257693259" compoundref="__generics_8py" startline="58">pydantic._internal._generics.GenericTypesCache</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1a1c055e35886a98db1334e04fc60f8be0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>type[<ref refid="classpydantic_1_1main_1_1_base_model" kindref="compound">BaseModel</ref>]|None</type>
        <definition> type[BaseModel] | None pydantic._internal._generics.get_cached_generic_type_late</definition>
        <argsstring>(type[BaseModel] parent, Any typevar_values, type[BaseModel] origin, tuple[Any,...] args)</argsstring>
        <name>get_cached_generic_type_late</name>
        <qualifiedname>pydantic._internal._generics.get_cached_generic_type_late</qualifiedname>
        <param>
          <type>type</type>
          <declname>parent</declname>
          <array>[BaseModel]</array>
        </param>
        <param>
          <type>Any</type>
          <declname>typevar_values</declname>
        </param>
        <param>
          <type>type</type>
          <declname>origin</declname>
          <array>[BaseModel]</array>
        </param>
        <param>
          <type>tuple</type>
          <declname>args</declname>
          <array>[Any,...]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>See the docstring of `get_cached_generic_type_early` for more information about the two-stage cache lookup.</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="462" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="464" bodyend="477"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a58fb0be9dd993d6b0c1659091ca30716" compoundref="__generics_8py" startline="534" endline="544">pydantic._internal._generics._late_cache_key</references>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a39a759bcb29ba97f166450d257693259" compoundref="__generics_8py" startline="58">pydantic._internal._generics.GenericTypesCache</references>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1ac46c5b5c5c2d0a221f8cda82b25ae9c0" compoundref="__generics_8py" startline="484" endline="500">pydantic._internal._generics.set_cached_generic_type</references>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1ac46c5b5c5c2d0a221f8cda82b25ae9c0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>None</type>
        <definition> None pydantic._internal._generics.set_cached_generic_type</definition>
        <argsstring>(type[BaseModel] parent, tuple[Any,...] typevar_values, type[BaseModel] type_, type[BaseModel]|None origin=None, tuple[Any,...]|None args=None)</argsstring>
        <name>set_cached_generic_type</name>
        <qualifiedname>pydantic._internal._generics.set_cached_generic_type</qualifiedname>
        <param>
          <type>type</type>
          <declname>parent</declname>
          <array>[BaseModel]</array>
        </param>
        <param>
          <type>tuple</type>
          <declname>typevar_values</declname>
          <array>[Any,...]</array>
        </param>
        <param>
          <type>type</type>
          <declname>type_</declname>
          <array>[BaseModel]</array>
        </param>
        <param>
          <type>type|None</type>
          <declname>origin</declname>
          <array>[BaseModel]</array>
          <defval>None</defval>
        </param>
        <param>
          <type>tuple|None</type>
          <declname>args</declname>
          <array>[Any,...]</array>
          <defval>None</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>See the docstring of `get_cached_generic_type_early` for more information about why items are cached with
two different keys.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="478" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="484" bodyend="500"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a0b982a936af6d27a669a64ff44d55fc4" compoundref="__generics_8py" startline="522" endline="533">pydantic._internal._generics._early_cache_key</references>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a58fb0be9dd993d6b0c1659091ca30716" compoundref="__generics_8py" startline="534" endline="544">pydantic._internal._generics._late_cache_key</references>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a39a759bcb29ba97f166450d257693259" compoundref="__generics_8py" startline="58">pydantic._internal._generics.GenericTypesCache</references>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1a1c055e35886a98db1334e04fc60f8be0" compoundref="__generics_8py" startline="464" endline="477">pydantic._internal._generics.get_cached_generic_type_late</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1ad1b2be56fbba991bdca0c593c464a6c2" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Any</type>
        <definition> Any pydantic._internal._generics._union_orderings_key</definition>
        <argsstring>(Any typevar_values)</argsstring>
        <name>_union_orderings_key</name>
        <qualifiedname>pydantic._internal._generics._union_orderings_key</qualifiedname>
        <param>
          <type>Any</type>
          <declname>typevar_values</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>This is intended to help differentiate between Union types with the same arguments in different order.

Thanks to caching internal to the `typing` module, it is not possible to distinguish between
List[Union[int, float]] and List[Union[float, int]] (and similarly for other &quot;parent&quot; origins besides List)
because `typing` considers Union[int, float] to be equal to Union[float, int].

However, you _can_ distinguish between (top-level) Union[int, float] vs. Union[float, int].
Because we parse items as the first Union type that is successful, we get slightly more consistent behavior
if we make an effort to distinguish the ordering of items in a union. It would be best if we could _always_
get the exact-correct order of items in the union, but that would require a change to the `typing` module itself.
(See https://github.com/python/cpython/issues/86483 for reference.)
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="501" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="501" bodyend="521"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1ad1b2be56fbba991bdca0c593c464a6c2" compoundref="__generics_8py" startline="501" endline="521">pydantic._internal._generics._union_orderings_key</references>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1a29a07a03dba4ccf370007eb6718cd7b9" compoundref="__generics_8py" startline="196" endline="202">pydantic._internal._generics.get_args</references>
        <references refid="namespacetyping__extensions_1a4bbba25af711824493b09a427463198d" compoundref="micro__gestion__objetos_2venv_2_lib_2site-packages_2typing__extensions_8py" startline="1577">typing_extensions.get_origin</references>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1a0b982a936af6d27a669a64ff44d55fc4" compoundref="__generics_8py" startline="522" endline="533">pydantic._internal._generics._early_cache_key</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1a58fb0be9dd993d6b0c1659091ca30716" compoundref="__generics_8py" startline="534" endline="544">pydantic._internal._generics._late_cache_key</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1ad1b2be56fbba991bdca0c593c464a6c2" compoundref="__generics_8py" startline="501" endline="521">pydantic._internal._generics._union_orderings_key</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1a0b982a936af6d27a669a64ff44d55fc4" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacepydantic_1_1__internal_1_1__generics_1af66dce654d9513143523a13ddec1ff64" kindref="member">GenericTypesCacheKey</ref></type>
        <definition> GenericTypesCacheKey pydantic._internal._generics._early_cache_key</definition>
        <argsstring>(type[BaseModel] cls, Any typevar_values)</argsstring>
        <name>_early_cache_key</name>
        <qualifiedname>pydantic._internal._generics._early_cache_key</qualifiedname>
        <param>
          <type>type</type>
          <declname>cls</declname>
          <array>[BaseModel]</array>
        </param>
        <param>
          <type>Any</type>
          <declname>typevar_values</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>This is intended for minimal computational overhead during lookups of cached types.

Note that this is overly simplistic, and it&apos;s possible that two different cls/typevar_values
inputs would ultimately result in the same type being created in BaseModel.__class_getitem__.
To handle this, we have a fallback _late_cache_key that is checked later if the _early_cache_key
lookup fails, and should result in a cache hit _precisely_ when the inputs to __class_getitem__
would result in the same type.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="522" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="522" bodyend="533"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1ad1b2be56fbba991bdca0c593c464a6c2" compoundref="__generics_8py" startline="501" endline="521">pydantic._internal._generics._union_orderings_key</references>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1a3c9314192feecb986c1a784369b212fa" compoundref="__generics_8py" startline="438" endline="461">pydantic._internal._generics.get_cached_generic_type_early</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1ac46c5b5c5c2d0a221f8cda82b25ae9c0" compoundref="__generics_8py" startline="484" endline="500">pydantic._internal._generics.set_cached_generic_type</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacepydantic_1_1__internal_1_1__generics_1a58fb0be9dd993d6b0c1659091ca30716" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacepydantic_1_1__internal_1_1__generics_1af66dce654d9513143523a13ddec1ff64" kindref="member">GenericTypesCacheKey</ref></type>
        <definition> GenericTypesCacheKey pydantic._internal._generics._late_cache_key</definition>
        <argsstring>(type[BaseModel] origin, tuple[Any,...] args, Any typevar_values)</argsstring>
        <name>_late_cache_key</name>
        <qualifiedname>pydantic._internal._generics._late_cache_key</qualifiedname>
        <param>
          <type>type</type>
          <declname>origin</declname>
          <array>[BaseModel]</array>
        </param>
        <param>
          <type>tuple</type>
          <declname>args</declname>
          <array>[Any,...]</array>
        </param>
        <param>
          <type>Any</type>
          <declname>typevar_values</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>This is intended for use later in the process of creating a new type, when we have more information
about the exact args that will be passed. If it turns out that a different set of inputs to
__class_getitem__ resulted in the same inputs to the generic type creation process, we can still
return the cached type, and update the cache with the _early_cache_key as well.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="534" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" bodystart="534" bodyend="544"/>
        <references refid="namespacepydantic_1_1__internal_1_1__generics_1ad1b2be56fbba991bdca0c593c464a6c2" compoundref="__generics_8py" startline="501" endline="521">pydantic._internal._generics._union_orderings_key</references>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1a1c055e35886a98db1334e04fc60f8be0" compoundref="__generics_8py" startline="464" endline="477">pydantic._internal._generics.get_cached_generic_type_late</referencedby>
        <referencedby refid="namespacepydantic_1_1__internal_1_1__generics_1ac46c5b5c5c2d0a221f8cda82b25ae9c0" compoundref="__generics_8py" startline="484" endline="500">pydantic._internal._generics.set_cached_generic_type</referencedby>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/_internal/_generics.py" line="1" column="1"/>
  </compounddef>
</doxygen>

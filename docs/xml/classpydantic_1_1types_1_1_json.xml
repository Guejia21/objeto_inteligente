<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="es">
  <compounddef id="classpydantic_1_1types_1_1_json" kind="class" language="Python" prot="public">
    <compoundname>pydantic::types::Json</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><verbatim>A special type wrapper which loads JSON before parsing.

You can use the `Json` data type to make Pydantic first load a raw JSON string before
validating the loaded data into the parametrized type:

```python
from typing import Any

from pydantic import BaseModel, Json, ValidationError

class AnyJsonModel(BaseModel):
    json_obj: Json[Any]

class ConstrainedJsonModel(BaseModel):
    json_obj: Json[list[int]]

print(AnyJsonModel(json_obj=&apos;{&quot;b&quot;: 1}&apos;))
#&gt; json_obj={&apos;b&apos;: 1}
print(ConstrainedJsonModel(json_obj=&apos;[1, 2, 3]&apos;))
#&gt; json_obj=[1, 2, 3]

try:
    ConstrainedJsonModel(json_obj=12)
except ValidationError as e:
    print(e)
    &apos;&apos;&apos;
    1 validation error for ConstrainedJsonModel
    json_obj
      JSON input should be string, bytes or bytearray [type=json_type, input_value=12, input_type=int]
    &apos;&apos;&apos;

try:
    ConstrainedJsonModel(json_obj=&apos;[a, b]&apos;)
except ValidationError as e:
    print(e)
    &apos;&apos;&apos;
    1 validation error for ConstrainedJsonModel
    json_obj
      Invalid JSON: expected value at line 1 column 2 [type=json_invalid, input_value=&apos;[a, b]&apos;, input_type=str]
    &apos;&apos;&apos;

try:
    ConstrainedJsonModel(json_obj=&apos;[&quot;a&quot;, &quot;b&quot;]&apos;)
except ValidationError as e:
    print(e)
    &apos;&apos;&apos;
    2 validation errors for ConstrainedJsonModel
    json_obj.0
      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value=&apos;a&apos;, input_type=str]
    json_obj.1
      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value=&apos;b&apos;, input_type=str]
    &apos;&apos;&apos;
```

When you dump the model using `model_dump` or `model_dump_json`, the dumped value will be the result of validation,
not the original JSON string. However, you can use the argument `round_trip=True` to get the original JSON string back:

```python
from pydantic import BaseModel, Json

class ConstrainedJsonModel(BaseModel):
    json_obj: Json[list[int]]

print(ConstrainedJsonModel(json_obj=&apos;[1, 2, 3]&apos;).model_dump_json())
#&gt; {&quot;json_obj&quot;:[1,2,3]}
print(
    ConstrainedJsonModel(json_obj=&apos;[1, 2, 3]&apos;).model_dump_json(round_trip=True)
)
#&gt; {&quot;json_obj&quot;:&quot;[1,2,3]&quot;}
```
</verbatim> </para>
    </detaileddescription>
    <location file="micro_gestion_objetos/venv/Lib/site-packages/pydantic/types.py" line="1436" column="1" bodyfile="micro_gestion_objetos/venv/Lib/site-packages/pydantic/types.py" bodystart="1436" bodyend="1532"/>
    <listofallmembers>
    </listofallmembers>
  </compounddef>
</doxygen>

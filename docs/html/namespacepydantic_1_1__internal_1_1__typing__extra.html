<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Objeto Inteligente - Sistema Completo: Referencia del espacio de nombres pydantic._internal._typing_extra</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Objeto Inteligente - Sistema Completo<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Sistema de gestión de objetos inteligentes con ontologías, microservicios y automatización IoT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Buscar',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacepydantic_1_1__internal_1_1__typing__extra.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Cargando...</div>
<div class="SRStatus" id="Searching">Buscando...</div>
<div class="SRStatus" id="NoMatches">Nada coincide</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Referencia del espacio de nombres pydantic._internal._typing_extra</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Funciones</h2></td></tr>
<tr class="memitem:a45180fdaefaf1c267b9a8bb0bd252272" id="r_a45180fdaefaf1c267b9a8bb0bd252272"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45180fdaefaf1c267b9a8bb0bd252272">is_annotated</a> (Any tp)</td></tr>
<tr class="memitem:a99661bd2b25e1ec6cd390822a1237d01" id="r_a99661bd2b25e1ec6cd390822a1237d01"><td class="memItemLeft" align="right" valign="top">Any|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99661bd2b25e1ec6cd390822a1237d01">annotated_type</a> (Any tp)</td></tr>
<tr class="memitem:a0bcd572a093197300cfebb7754ff62e9" id="r_a0bcd572a093197300cfebb7754ff62e9"><td class="memItemLeft" align="right" valign="top">Any|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bcd572a093197300cfebb7754ff62e9">unpack_type</a> (Any tp)</td></tr>
<tr class="memitem:a8e6c8626806dd47115d01e2d01f5b92f" id="r_a8e6c8626806dd47115d01e2d01f5b92f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e6c8626806dd47115d01e2d01f5b92f">is_hashable</a> (Any tp)</td></tr>
<tr class="memitem:a4d3b8918c37aab211b4ef4d7a99fa2e7" id="r_a4d3b8918c37aab211b4ef4d7a99fa2e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d3b8918c37aab211b4ef4d7a99fa2e7">is_callable</a> (Any tp)</td></tr>
<tr class="memitem:ab9b396ab22b04a47c0ba928be1bfc8b9" id="r_ab9b396ab22b04a47c0ba928be1bfc8b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9b396ab22b04a47c0ba928be1bfc8b9">is_classvar_annotation</a> (Any tp)</td></tr>
<tr class="memitem:af35ef9b72be371b28ca97eec76d32d93" id="r_af35ef9b72be371b28ca97eec76d32d93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af35ef9b72be371b28ca97eec76d32d93">is_finalvar</a> (Any tp)</td></tr>
<tr class="memitem:a3575d6caa222e84ee49c1fc448cc5376" id="r_a3575d6caa222e84ee49c1fc448cc5376"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3575d6caa222e84ee49c1fc448cc5376">is_none_type</a> (Any tp)</td></tr>
<tr class="memitem:a0e8fffc7c696df6b8d92cc8697d87f29" id="r_a0e8fffc7c696df6b8d92cc8697d87f29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e8fffc7c696df6b8d92cc8697d87f29">is_namedtuple</a> (Any tp)</td></tr>
<tr class="memitem:aef64776ff271e90da4465f923c8879c7" id="r_aef64776ff271e90da4465f923c8879c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef64776ff271e90da4465f923c8879c7">is_generic_alias</a> (Any tp)</td></tr>
<tr class="memitem:a903c238cab7e5524554936975ea038f3" id="r_a903c238cab7e5524554936975ea038f3"><td class="memItemLeft" align="right" valign="top">dict[str, Any]|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a903c238cab7e5524554936975ea038f3">parent_frame_namespace</a> (*, int parent_depth=2, bool force=False)</td></tr>
<tr class="memdesc:a903c238cab7e5524554936975ea038f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation evaluations functions:  <br /></td></tr>
<tr class="memitem:aab3a68826d073fef0b2a420c85f1ce2a" id="r_aab3a68826d073fef0b2a420c85f1ce2a"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab3a68826d073fef0b2a420c85f1ce2a">_type_convert</a> (Any arg)</td></tr>
<tr class="memitem:a26db667a0b46a87a4f1102feadb33c44" id="r_a26db667a0b46a87a4f1102feadb33c44"><td class="memItemLeft" align="right" valign="top">dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26db667a0b46a87a4f1102feadb33c44">safe_get_annotations</a> (type[Any] cls)</td></tr>
<tr class="memitem:a1cb290529bac465420babead796f7ddb" id="r_a1cb290529bac465420babead796f7ddb"><td class="memItemLeft" align="right" valign="top">dict[str, tuple[Any, bool]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cb290529bac465420babead796f7ddb">get_model_type_hints</a> (type[<a class="el" href="classpydantic_1_1main_1_1_base_model.html">BaseModel</a>] obj, *, <a class="el" href="classpydantic_1_1__internal_1_1__namespace__utils_1_1_ns_resolver.html">NsResolver</a>|None ns_resolver=None)</td></tr>
<tr class="memitem:aa9da33fec8cf619921d6eaf2f851eafc" id="r_aa9da33fec8cf619921d6eaf2f851eafc"><td class="memItemLeft" align="right" valign="top">dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9da33fec8cf619921d6eaf2f851eafc">get_cls_type_hints</a> (type[Any] obj, *, <a class="el" href="classpydantic_1_1__internal_1_1__namespace__utils_1_1_ns_resolver.html">NsResolver</a>|None ns_resolver=None)</td></tr>
<tr class="memitem:a5e006ee81f2e61286fbae800a51a85b2" id="r_a5e006ee81f2e61286fbae800a51a85b2"><td class="memItemLeft" align="right" valign="top">tuple[Any, bool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e006ee81f2e61286fbae800a51a85b2">try_eval_type</a> (Any value, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None)</td></tr>
<tr class="memitem:ac9c3af1324526675b9c24dccce4aab9f" id="r_ac9c3af1324526675b9c24dccce4aab9f"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9c3af1324526675b9c24dccce4aab9f">eval_type</a> (Any value, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None)</td></tr>
<tr class="memitem:aaea229040f97397636138d4d06fd40db" id="r_aaea229040f97397636138d4d06fd40db"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaea229040f97397636138d4d06fd40db">eval_type_lenient</a> (Any value, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None)</td></tr>
<tr class="memitem:ab7290a6cd837bb3d1ec1a618507eaea4" id="r_ab7290a6cd837bb3d1ec1a618507eaea4"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7290a6cd837bb3d1ec1a618507eaea4">eval_type_backport</a> (Any value, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None, tuple[Any,...]|None type_params=None)</td></tr>
<tr class="memitem:a45406bee2532b7faa887ba41b710db1f" id="r_a45406bee2532b7faa887ba41b710db1f"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45406bee2532b7faa887ba41b710db1f">_eval_type_backport</a> (Any value, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None, tuple[Any,...]|None type_params=None)</td></tr>
<tr class="memitem:a61ca1a81adf03010552a02b18dd032c5" id="r_a61ca1a81adf03010552a02b18dd032c5"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61ca1a81adf03010552a02b18dd032c5">_eval_type</a> (Any value, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None, tuple[Any,...]|None type_params=None)</td></tr>
<tr class="memitem:a92994be9acf5744dee7747fc8c1508bc" id="r_a92994be9acf5744dee7747fc8c1508bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92994be9acf5744dee7747fc8c1508bc">is_backport_fixable_error</a> (TypeError e)</td></tr>
<tr class="memitem:ad01a7e54e574e426e80d34c0e11664f5" id="r_ad01a7e54e574e426e80d34c0e11664f5"><td class="memItemLeft" align="right" valign="top">dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad01a7e54e574e426e80d34c0e11664f5">get_function_type_hints</a> (Callable[..., Any] function, *, set[str]|None include_keys=None, GlobalsNamespace|None globalns=None, MappingNamespace|None localns=None)</td></tr>
<tr class="memitem:ae593fb76bf8880044e563bf38b30d9b4" id="r_ae593fb76bf8880044e563bf38b30d9b4"><td class="memItemLeft" align="right" valign="top">typing.ForwardRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae593fb76bf8880044e563bf38b30d9b4">_make_forward_ref</a> (Any arg, bool is_argument=True, *, bool is_class=False)</td></tr>
<tr class="memitem:ab2b3e02aeaab5f00fae0d35d7ddfebda" id="r_ab2b3e02aeaab5f00fae0d35d7ddfebda"><td class="memItemLeft" align="right" valign="top">dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2b3e02aeaab5f00fae0d35d7ddfebda">get_type_hints</a> (Any obj, dict[str, Any]|None globalns=None, dict[str, Any]|None localns=None, bool include_extras=False)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa17a793985242eb23b25e177bcd614d4" id="r_aa17a793985242eb23b25e177bcd614d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa17a793985242eb23b25e177bcd614d4">NoneType</a> = type(None)</td></tr>
<tr class="memitem:a1de812f438e3a8c14dbed15d4b24cb3d" id="r_a1de812f438e3a8c14dbed15d4b24cb3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1de812f438e3a8c14dbed15d4b24cb3d">EllipsisType</a> = type(Ellipsis)</td></tr>
<tr class="memitem:a69300f541061de4c1da5c97b1b46eb03" id="r_a69300f541061de4c1da5c97b1b46eb03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69300f541061de4c1da5c97b1b46eb03">_t_annotated</a> = typing.Annotated</td></tr>
<tr class="memitem:a0b18795640831ce15828390854f8db51" id="r_a0b18795640831ce15828390854f8db51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b18795640831ce15828390854f8db51">_te_annotated</a> = <a class="el" href="namespacetyping__extensions.html#a20da5b454038eb0a30cafecc2b9ffad3">typing_extensions.Annotated</a></td></tr>
<tr class="memitem:a551483d2f59054eef6e76af72fad463a" id="r_a551483d2f59054eef6e76af72fad463a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a551483d2f59054eef6e76af72fad463a">_classvar_re</a> = re.compile(r'((\w+\.)?Annotated\[)?(\w+\.)?ClassVar\[')</td></tr>
<tr class="memitem:a4551578118c732b7e7c5959bdf436db2" id="r_a4551578118c732b7e7c5959bdf436db2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4551578118c732b7e7c5959bdf436db2">_t_final</a> = typing.Final</td></tr>
<tr class="memitem:a60e2512374d259218f84ad8ea0131770" id="r_a60e2512374d259218f84ad8ea0131770"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60e2512374d259218f84ad8ea0131770">_te_final</a> = <a class="el" href="namespacetyping__extensions.html#a0d07e9ea4b1615c24ead0a5a81956720">typing_extensions.Final</a></td></tr>
<tr class="memitem:a90c2647b3e7a0a710c63bcf4deaee47d" id="r_a90c2647b3e7a0a710c63bcf4deaee47d"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90c2647b3e7a0a710c63bcf4deaee47d">_NONE_TYPES</a> = (None, <a class="el" href="#aa17a793985242eb23b25e177bcd614d4">NoneType</a>, typing.Literal[None], <a class="el" href="namespacetyping__extensions.html#a086bf483786f7be28e26fbe4e2b9958a">typing_extensions.Literal</a>[None])</td></tr>
<tr class="memitem:aeee38a8b46e718faf52906bd99858255" id="r_aeee38a8b46e718faf52906bd99858255"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeee38a8b46e718faf52906bd99858255">origin_is_union</a> = is_union_origin</td></tr>
<tr class="memitem:a53a2f2bfacdeb0940d2f9c7a729cbb88" id="r_a53a2f2bfacdeb0940d2f9c7a729cbb88"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53a2f2bfacdeb0940d2f9c7a729cbb88">WithArgsTypes</a> = (typing._GenericAlias, types.GenericAlias)</td></tr>
<tr class="memitem:a7991f33a5bf97c4daedad2224688e557" id="r_a7991f33a5bf97c4daedad2224688e557"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7991f33a5bf97c4daedad2224688e557">typing_base</a> = typing._Final</td></tr>
<tr class="memitem:a11c62f214b0382d7471ad77300288e40" id="r_a11c62f214b0382d7471ad77300288e40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11c62f214b0382d7471ad77300288e40">_make_forward_ref</a> = typing.ForwardRef</td></tr>
<tr class="memitem:af9ba279b2237d6f69b9f7272595c98fb" id="r_af9ba279b2237d6f69b9f7272595c98fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9ba279b2237d6f69b9f7272595c98fb">get_type_hints</a> = typing.get_type_hints</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Descripción detallada</h2>
<div class="textblock"><pre class="fragment">Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap Python's typing module.</pre> </div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Documentación de funciones</h2>
<a id="a61ca1a81adf03010552a02b18dd032c5" name="a61ca1a81adf03010552a02b18dd032c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ca1a81adf03010552a02b18dd032c5">&#9670;&#160;</a></span>_eval_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Any pydantic._internal._typing_extra._eval_type </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None </td>          <td class="paramname"><span class="paramname"><em>globalns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None </td>          <td class="paramname"><span class="paramname"><em>localns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[Any, ...] | None </td>          <td class="paramname"><span class="paramname"><em>type_params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00515">515</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Referenciado por <a class="el" href="__typing__extra_8py_source.html#l00490">_eval_type_backport()</a>.</p>

</div>
</div>
<a id="a45406bee2532b7faa887ba41b710db1f" name="a45406bee2532b7faa887ba41b710db1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45406bee2532b7faa887ba41b710db1f">&#9670;&#160;</a></span>_eval_type_backport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Any pydantic._internal._typing_extra._eval_type_backport </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None </td>          <td class="paramname"><span class="paramname"><em>globalns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None </td>          <td class="paramname"><span class="paramname"><em>localns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[Any, ...] | None </td>          <td class="paramname"><span class="paramname"><em>type_params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00485">485</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="__typing__extra_8py_source.html#l00520">_eval_type()</a>, <a class="el" href="__typing__extra_8py_source.html#l00444">eval_type_backport()</a> y <a class="el" href="__typing__extra_8py_source.html#l00543">is_backport_fixable_error()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="__typing__extra_8py_source.html#l00444">eval_type_backport()</a>.</p>

</div>
</div>
<a id="ae593fb76bf8880044e563bf38b30d9b4" name="ae593fb76bf8880044e563bf38b30d9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae593fb76bf8880044e563bf38b30d9b4">&#9670;&#160;</a></span>_make_forward_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> typing.ForwardRef pydantic._internal._typing_extra._make_forward_ref </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>is_argument</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>is_class</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Wrapper for ForwardRef that accounts for the `is_class` argument missing in older versions.
The `module` argument is omitted as it breaks &lt;3.9.8, =3.10.0 and isn't used in the calls below.

See https://github.com/python/cpython/pull/28560 for some background.
The backport happened on 3.9.8, see:
https://github.com/pydantic/pydantic/discussions/6244#discussioncomment-6275458,
and on 3.10.1 for the 3.10 branch, see:
https://github.com/pydantic/pydantic/issues/6912

Implemented as EAFP with memory.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00597">597</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="aab3a68826d073fef0b2a420c85f1ce2a" name="aab3a68826d073fef0b2a420c85f1ce2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3a68826d073fef0b2a420c85f1ce2a">&#9670;&#160;</a></span>_type_convert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Any pydantic._internal._typing_extra._type_convert </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert `None` to `NoneType` and strings to `ForwardRef` instances.

This is a backport of the private `typing._type_convert` function. When
evaluating a type, `ForwardRef._evaluate` ends up being called, and is
responsible for making this conversion. However, we still have to apply
it for the first argument passed to our type evaluation functions, similarly
to the `typing.get_type_hints` function.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00277">277</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="__typing__extra_8py_source.html#l00617">_make_forward_ref</a>.</p>

<p class="reference">Referenciado por <a class="el" href="__typing__extra_8py_source.html#l00413">eval_type()</a> y <a class="el" href="__typing__extra_8py_source.html#l00388">try_eval_type()</a>.</p>

</div>
</div>
<a id="a99661bd2b25e1ec6cd390822a1237d01" name="a99661bd2b25e1ec6cd390822a1237d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99661bd2b25e1ec6cd390822a1237d01">&#9670;&#160;</a></span>annotated_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any | None pydantic._internal._typing_extra.annotated_type </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>tp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the type of the `Annotated` special form, or `None`.</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00057">57</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="ac9c3af1324526675b9c24dccce4aab9f" name="ac9c3af1324526675b9c24dccce4aab9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c3af1324526675b9c24dccce4aab9f">&#9670;&#160;</a></span>eval_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any pydantic._internal._typing_extra.eval_type </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None </td>          <td class="paramname"><span class="paramname"><em>globalns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None </td>          <td class="paramname"><span class="paramname"><em>localns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate the annotation using the provided namespaces.

Args:
    value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance
        of `str`, it will be converted to a `ForwardRef`.
    localns: The global namespace to use during annotation evaluation.
    globalns: The local namespace to use during annotation evaluation.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00409">409</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="__typing__extra_8py_source.html#l00277">_type_convert()</a> y <a class="el" href="__typing__extra_8py_source.html#l00444">eval_type_backport()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="__typing__extra_8py_source.html#l00358">get_cls_type_hints()</a>.</p>

</div>
</div>
<a id="ab7290a6cd837bb3d1ec1a618507eaea4" name="ab7290a6cd837bb3d1ec1a618507eaea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7290a6cd837bb3d1ec1a618507eaea4">&#9670;&#160;</a></span>eval_type_backport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any pydantic._internal._typing_extra.eval_type_backport </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None </td>          <td class="paramname"><span class="paramname"><em>globalns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None </td>          <td class="paramname"><span class="paramname"><em>localns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[Any, ...] | None </td>          <td class="paramname"><span class="paramname"><em>type_params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An enhanced version of `typing._eval_type` which will fall back to using the `eval_type_backport`
package if it's installed to let older Python versions use newer typing constructs.

Specifically, this transforms `X | Y` into `typing.Union[X, Y]` and `list[X]` into `typing.List[X]`
(as well as all the types made generic in PEP 585) if the original syntax is not supported in the
current Python version.

This function will also display a helpful error if the value passed fails to evaluate.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00439">439</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="__typing__extra_8py_source.html#l00490">_eval_type_backport()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="__typing__extra_8py_source.html#l00490">_eval_type_backport()</a>, <a class="el" href="__typing__extra_8py_source.html#l00413">eval_type()</a>, <a class="el" href="__typing__extra_8py_source.html#l00555">get_function_type_hints()</a>, <a class="el" href="__typing__extra_8py_source.html#l00635">get_type_hints()</a> y <a class="el" href="__typing__extra_8py_source.html#l00388">try_eval_type()</a>.</p>

</div>
</div>
<a id="aaea229040f97397636138d4d06fd40db" name="aaea229040f97397636138d4d06fd40db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea229040f97397636138d4d06fd40db">&#9670;&#160;</a></span>eval_type_lenient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any pydantic._internal._typing_extra.eval_type_lenient </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None </td>          <td class="paramname"><span class="paramname"><em>globalns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None </td>          <td class="paramname"><span class="paramname"><em>localns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00430">430</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="__typing__extra_8py_source.html#l00388">try_eval_type()</a>.</p>

</div>
</div>
<a id="aa9da33fec8cf619921d6eaf2f851eafc" name="aa9da33fec8cf619921d6eaf2f851eafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9da33fec8cf619921d6eaf2f851eafc">&#9670;&#160;</a></span>get_cls_type_hints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, Any] pydantic._internal._typing_extra.get_cls_type_hints </td>
          <td>(</td>
          <td class="paramtype">type[Any]</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1__internal_1_1__namespace__utils_1_1_ns_resolver.html">NsResolver</a> | None </td>          <td class="paramname"><span class="paramname"><em>ns_resolver</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Collect annotations from a class, including those from parent classes.

Args:
    obj: The class to inspect.
    ns_resolver: A namespace resolver instance to use. Defaults to an empty instance.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00354">354</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="__typing__extra_8py_source.html#l00413">eval_type()</a> y <a class="el" href="__typing__extra_8py_source.html#l00295">safe_get_annotations()</a>.</p>

</div>
</div>
<a id="ad01a7e54e574e426e80d34c0e11664f5" name="ad01a7e54e574e426e80d34c0e11664f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01a7e54e574e426e80d34c0e11664f5">&#9670;&#160;</a></span>get_function_type_hints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, Any] pydantic._internal._typing_extra.get_function_type_hints </td>
          <td>(</td>
          <td class="paramtype">Callable[..., Any]</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set[str] | None </td>          <td class="paramname"><span class="paramname"><em>include_keys</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None </td>          <td class="paramname"><span class="paramname"><em>globalns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None </td>          <td class="paramname"><span class="paramname"><em>localns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return type hints for a function.

This is similar to the `typing.get_type_hints` function, with a few differences:
- Support `functools.partial` by using the underlying `func` attribute.
- Do not wrap type annotation of a parameter with `Optional` if it has a default value of `None`
  (related bug: https://github.com/python/cpython/issues/90353, only fixed in 3.11+).
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00549">549</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="__typing__extra_8py_source.html#l00617">_make_forward_ref</a> y <a class="el" href="__typing__extra_8py_source.html#l00444">eval_type_backport()</a>.</p>

</div>
</div>
<a id="a1cb290529bac465420babead796f7ddb" name="a1cb290529bac465420babead796f7ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb290529bac465420babead796f7ddb">&#9670;&#160;</a></span>get_model_type_hints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, tuple[Any, bool]] pydantic._internal._typing_extra.get_model_type_hints </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="classpydantic_1_1main_1_1_base_model.html">BaseModel</a>]</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1__internal_1_1__namespace__utils_1_1_ns_resolver.html">NsResolver</a> | None </td>          <td class="paramname"><span class="paramname"><em>ns_resolver</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Collect annotations from a Pydantic model class, including those from parent classes.

Args:
    obj: The Pydantic model to inspect.
    ns_resolver: A namespace resolver instance to use. Defaults to an empty instance.

Returns:
    A dictionary mapping annotation names to a two-tuple: the first element is the evaluated
    type or the original annotation if a `NameError` occurred, the second element is a boolean
    indicating if whether the evaluation succeeded.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00308">308</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="__typing__extra_8py_source.html#l00295">safe_get_annotations()</a> y <a class="el" href="__typing__extra_8py_source.html#l00388">try_eval_type()</a>.</p>

</div>
</div>
<a id="ab2b3e02aeaab5f00fae0d35d7ddfebda" name="ab2b3e02aeaab5f00fae0d35d7ddfebda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b3e02aeaab5f00fae0d35d7ddfebda">&#9670;&#160;</a></span>get_type_hints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, Any] pydantic._internal._typing_extra.get_type_hints </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None </td>          <td class="paramname"><span class="paramname"><em>globalns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, Any] | None </td>          <td class="paramname"><span class="paramname"><em>localns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>include_extras</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Taken verbatim from python 3.10.8 unchanged, except:
* type annotations of the function definition above.
* prefixing `typing.` where appropriate
* Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument.

https://github.com/python/cpython/blob/aaaf5174241496afca7ce4d4584570190ff972fe/Lib/typing.py#L1773-L1875

DO NOT CHANGE THIS METHOD UNLESS ABSOLUTELY NECESSARY.
======================================================

Return type hints for an object.

This is often the same as obj.__annotations__, but it handles
forward references encoded as string literals, adds Optional[t] if a
default value equal to None is set and recursively replaces all
'Annotated[T, ...]' with 'T' (unless 'include_extras=True').

The argument may be a module, class, method, or function. The annotations
are returned as a dictionary. For classes, annotations include also
inherited members.

TypeError is raised if the argument is not of a type that can contain
annotations, and an empty dictionary is returned if no annotations are
present.

BEWARE -- the behavior of globalns and localns is counterintuitive
(unless you are familiar with how eval() and exec() work).  The
search order is locals first, then globals.

- If no dict arguments are passed, an attempt is made to use the
  globals from obj (or the respective module's globals for classes),
  and these are also used as the locals.  If the object does not appear
  to have globals, an empty dictionary is used.  For classes, the search
  order is globals first then locals.

- If one dict argument is passed, it is used for both globals and
  locals.

- If two dict arguments are passed, they specify globals and
  locals, respectively.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00630">630</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="__typing__extra_8py_source.html#l00617">_make_forward_ref</a> y <a class="el" href="__typing__extra_8py_source.html#l00444">eval_type_backport()</a>.</p>

</div>
</div>
<a id="a45180fdaefaf1c267b9a8bb0bd252272" name="a45180fdaefaf1c267b9a8bb0bd252272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45180fdaefaf1c267b9a8bb0bd252272">&#9670;&#160;</a></span>is_annotated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_annotated </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>tp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `Annotated` special form.

```python {test="skip" lint="skip"}
is_annotated(Annotated[int, ...])
#&gt; True
```
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00045">45</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a92994be9acf5744dee7747fc8c1508bc" name="a92994be9acf5744dee7747fc8c1508bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92994be9acf5744dee7747fc8c1508bc">&#9670;&#160;</a></span>is_backport_fixable_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_backport_fixable_error </td>
          <td>(</td>
          <td class="paramtype">TypeError</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00543">543</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Referenciado por <a class="el" href="__typing__extra_8py_source.html#l00490">_eval_type_backport()</a>.</p>

</div>
</div>
<a id="a4d3b8918c37aab211b4ef4d7a99fa2e7" name="a4d3b8918c37aab211b4ef4d7a99fa2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3b8918c37aab211b4ef4d7a99fa2e7">&#9670;&#160;</a></span>is_callable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_callable </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>tp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `Callable`, parametrized or not.

```python {test="skip" lint="skip"}
is_callable(Callable[[int], str])
#&gt; True
is_callable(typing.Callable)
#&gt; True
is_callable(collections.abc.Callable)
#&gt; True
```
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00080">80</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="ab9b396ab22b04a47c0ba928be1bfc8b9" name="ab9b396ab22b04a47c0ba928be1bfc8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b396ab22b04a47c0ba928be1bfc8b9">&#9670;&#160;</a></span>is_classvar_annotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_classvar_annotation </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>tp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument represents a class variable annotation.

Although not explicitly stated by the typing specification, `ClassVar` can be used
inside `Annotated` and as such, this function checks for this specific scenario.

Because this function is used to detect class variables before evaluating forward references
(or because evaluation failed), we also implement a naive regex match implementation. This is
required because class variables are inspected before fields are collected, so we try to be
as accurate as possible.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00100">100</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="af35ef9b72be371b28ca97eec76d32d93" name="af35ef9b72be371b28ca97eec76d32d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35ef9b72be371b28ca97eec76d32d93">&#9670;&#160;</a></span>is_finalvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_finalvar </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>tp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a `Final` special form, parametrized or not.

```python {test="skip" lint="skip"}
is_finalvar(Final[int])
#&gt; True
is_finalvar(Final)
#&gt; True
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00143">143</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="aef64776ff271e90da4465f923c8879c7" name="aef64776ff271e90da4465f923c8879c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef64776ff271e90da4465f923c8879c7">&#9670;&#160;</a></span>is_generic_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_generic_alias </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>tp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00194">194</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a8e6c8626806dd47115d01e2d01f5b92f" name="a8e6c8626806dd47115d01e2d01f5b92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6c8626806dd47115d01e2d01f5b92f">&#9670;&#160;</a></span>is_hashable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_hashable </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>tp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is the `Hashable` class.

```python {test="skip" lint="skip"}
is_hashable(Hashable)
#&gt; True
```
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00067">67</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a0e8fffc7c696df6b8d92cc8697d87f29" name="a0e8fffc7c696df6b8d92cc8697d87f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8fffc7c696df6b8d92cc8697d87f29">&#9670;&#160;</a></span>is_namedtuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_namedtuple </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>tp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the provided argument is a named tuple class.

The class can be created using `typing.NamedTuple` or `collections.namedtuple`.
Parametrized generic classes are *not* assumed to be named tuples.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00178">178</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a3575d6caa222e84ee49c1fc448cc5376" name="a3575d6caa222e84ee49c1fc448cc5376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3575d6caa222e84ee49c1fc448cc5376">&#9670;&#160;</a></span>is_none_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pydantic._internal._typing_extra.is_none_type </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>tp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the argument represents the `None` type as part of an annotation.

```python {test="skip" lint="skip"}
is_none_type(None)
#&gt; True
is_none_type(NoneType)
#&gt; True
is_none_type(Literal[None])
#&gt; True
is_none_type(type[None])
#&gt; False
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00162">162</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a903c238cab7e5524554936975ea038f3" name="a903c238cab7e5524554936975ea038f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903c238cab7e5524554936975ea038f3">&#9670;&#160;</a></span>parent_frame_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, Any] | None pydantic._internal._typing_extra.parent_frame_namespace </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>parent_depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>force</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotation evaluations functions: </p>
<pre class="fragment">Fetch the local namespace of the parent frame where this function is called.

Using this function is mostly useful to resolve forward annotations pointing to members defined in a local namespace,
such as assignments inside a function. Using the standard library tools, it is currently not possible to resolve
such annotations:

```python {lint="skip" test="skip"}
from typing import get_type_hints

def func() -&gt; None:
    Alias = int

    class C:
        a: 'Alias'

    # Raises a `NameError: 'Alias' is not defined`
    get_type_hints(C)
```

Pydantic uses this function when a Pydantic model is being defined to fetch the parent frame locals. However,
this only allows us to fetch the parent frame namespace and not other parents (e.g. a model defined in a function,
itself defined in another function). Inspecting the next outer frames (using `f_back`) is not reliable enough
(see https://discuss.python.org/t/20659).

Because this function is mostly used to better resolve forward annotations, nothing is returned if the parent frame's
code object is defined at the module level. In this case, the locals of the frame will be the same as the module
globals where the class is defined (see `_namespace_utils.get_module_ns_of`). However, if you still want to fetch
the module globals (e.g. when rebuilding a model, where the frame where the rebuild call is performed might contain
members that you want to use for forward annotations evaluation), you can use the `force` parameter.

Args:
    parent_depth: The depth at which to get the frame. Defaults to 2, meaning the parent frame where this function
        is called will be used.
    force: Whether to always return the frame locals, even if the frame's code object is defined at the module level.

Returns:
    The locals of the namespace, or `None` if it was skipped as per the described logic.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00213">213</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a26db667a0b46a87a4f1102feadb33c44" name="a26db667a0b46a87a4f1102feadb33c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26db667a0b46a87a4f1102feadb33c44">&#9670;&#160;</a></span>safe_get_annotations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[str, Any] pydantic._internal._typing_extra.safe_get_annotations </td>
          <td>(</td>
          <td class="paramtype">type[Any]</td>          <td class="paramname"><span class="paramname"><em>cls</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the annotations for the provided class, accounting for potential deferred forward references.

Starting with Python 3.14, accessing the `__annotations__` attribute might raise a `NameError` if
a referenced symbol isn't defined yet. In this case, we return the annotation in the *forward ref*
format.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00295">295</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Referenciado por <a class="el" href="__typing__extra_8py_source.html#l00358">get_cls_type_hints()</a> y <a class="el" href="__typing__extra_8py_source.html#l00312">get_model_type_hints()</a>.</p>

</div>
</div>
<a id="a5e006ee81f2e61286fbae800a51a85b2" name="a5e006ee81f2e61286fbae800a51a85b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e006ee81f2e61286fbae800a51a85b2">&#9670;&#160;</a></span>try_eval_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[Any, bool] pydantic._internal._typing_extra.try_eval_type </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalsNamespace | None </td>          <td class="paramname"><span class="paramname"><em>globalns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingNamespace | None </td>          <td class="paramname"><span class="paramname"><em>localns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try evaluating the annotation using the provided namespaces.

Args:
    value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance
        of `str`, it will be converted to a `ForwardRef`.
    localns: The global namespace to use during annotation evaluation.
    globalns: The local namespace to use during annotation evaluation.

Returns:
    A two-tuple containing the possibly evaluated type and a boolean indicating
        whether the evaluation succeeded or not.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00384">384</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="__typing__extra_8py_source.html#l00277">_type_convert()</a> y <a class="el" href="__typing__extra_8py_source.html#l00444">eval_type_backport()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="__typing__extra_8py_source.html#l00434">eval_type_lenient()</a> y <a class="el" href="__typing__extra_8py_source.html#l00312">get_model_type_hints()</a>.</p>

</div>
</div>
<a id="a0bcd572a093197300cfebb7754ff62e9" name="a0bcd572a093197300cfebb7754ff62e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcd572a093197300cfebb7754ff62e9">&#9670;&#160;</a></span>unpack_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any | None pydantic._internal._typing_extra.unpack_type </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>tp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the type wrapped by the `Unpack` special form, or `None`.</pre> 
<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00062">62</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Documentación de variables</h2>
<a id="a551483d2f59054eef6e76af72fad463a" name="a551483d2f59054eef6e76af72fad463a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551483d2f59054eef6e76af72fad463a">&#9670;&#160;</a></span>_classvar_re</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra._classvar_re = re.compile(r'((\w+\.)?Annotated\[)?(\w+\.)?ClassVar\[')</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00097">97</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a11c62f214b0382d7471ad77300288e40" name="a11c62f214b0382d7471ad77300288e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c62f214b0382d7471ad77300288e40">&#9670;&#160;</a></span>_make_forward_ref</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra._make_forward_ref = typing.ForwardRef</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00617">617</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

<p class="reference">Referenciado por <a class="el" href="__typing__extra_8py_source.html#l00277">_type_convert()</a>, <a class="el" href="__typing__extra_8py_source.html#l00555">get_function_type_hints()</a> y <a class="el" href="__typing__extra_8py_source.html#l00635">get_type_hints()</a>.</p>

</div>
</div>
<a id="a90c2647b3e7a0a710c63bcf4deaee47d" name="a90c2647b3e7a0a710c63bcf4deaee47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c2647b3e7a0a710c63bcf4deaee47d">&#9670;&#160;</a></span>_NONE_TYPES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple pydantic._internal._typing_extra._NONE_TYPES = (None, <a class="el" href="#aa17a793985242eb23b25e177bcd614d4">NoneType</a>, typing.Literal[None], <a class="el" href="namespacetyping__extensions.html#a086bf483786f7be28e26fbe4e2b9958a">typing_extensions.Literal</a>[None])</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00159">159</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a69300f541061de4c1da5c97b1b46eb03" name="a69300f541061de4c1da5c97b1b46eb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69300f541061de4c1da5c97b1b46eb03">&#9670;&#160;</a></span>_t_annotated</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra._t_annotated = typing.Annotated</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00041">41</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a4551578118c732b7e7c5959bdf436db2" name="a4551578118c732b7e7c5959bdf436db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4551578118c732b7e7c5959bdf436db2">&#9670;&#160;</a></span>_t_final</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra._t_final = typing.Final</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00138">138</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a0b18795640831ce15828390854f8db51" name="a0b18795640831ce15828390854f8db51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b18795640831ce15828390854f8db51">&#9670;&#160;</a></span>_te_annotated</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra._te_annotated = <a class="el" href="namespacetyping__extensions.html#a20da5b454038eb0a30cafecc2b9ffad3">typing_extensions.Annotated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00042">42</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a60e2512374d259218f84ad8ea0131770" name="a60e2512374d259218f84ad8ea0131770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e2512374d259218f84ad8ea0131770">&#9670;&#160;</a></span>_te_final</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra._te_final = <a class="el" href="namespacetyping__extensions.html#a0d07e9ea4b1615c24ead0a5a81956720">typing_extensions.Final</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00139">139</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a1de812f438e3a8c14dbed15d4b24cb3d" name="a1de812f438e3a8c14dbed15d4b24cb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de812f438e3a8c14dbed15d4b24cb3d">&#9670;&#160;</a></span>EllipsisType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra.EllipsisType = type(Ellipsis)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00024">24</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="af9ba279b2237d6f69b9f7272595c98fb" name="af9ba279b2237d6f69b9f7272595c98fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ba279b2237d6f69b9f7272595c98fb">&#9670;&#160;</a></span>get_type_hints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra.get_type_hints = typing.get_type_hints</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00621">621</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="aa17a793985242eb23b25e177bcd614d4" name="aa17a793985242eb23b25e177bcd614d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17a793985242eb23b25e177bcd614d4">&#9670;&#160;</a></span>NoneType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra.NoneType = type(None)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00023">23</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="aeee38a8b46e718faf52906bd99858255" name="aeee38a8b46e718faf52906bd99858255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee38a8b46e718faf52906bd99858255">&#9670;&#160;</a></span>origin_is_union</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic._internal._typing_extra.origin_is_union = is_union_origin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00191">191</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a7991f33a5bf97c4daedad2224688e557" name="a7991f33a5bf97c4daedad2224688e557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7991f33a5bf97c4daedad2224688e557">&#9670;&#160;</a></span>typing_base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Any pydantic._internal._typing_extra.typing_base = typing._Final</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00207">207</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
<a id="a53a2f2bfacdeb0940d2f9c7a729cbb88" name="a53a2f2bfacdeb0940d2f9c7a729cbb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a2f2bfacdeb0940d2f9c7a729cbb88">&#9670;&#160;</a></span>WithArgsTypes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple pydantic._internal._typing_extra.WithArgsTypes = (typing._GenericAlias, types.GenericAlias)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="__typing__extra_8py_source.html#l00201">201</a> del archivo <a class="el" href="__typing__extra_8py_source.html">_typing_extra.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacepydantic.html">pydantic</a></li><li class="navelem"><a href="namespacepydantic_1_1__internal.html">_internal</a></li><li class="navelem"><a href="namespacepydantic_1_1__internal_1_1__typing__extra.html">_typing_extra</a></li>
    <li class="footer">Generado el <span class="timestamp"></span> para Objeto Inteligente - Sistema Completo por <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>

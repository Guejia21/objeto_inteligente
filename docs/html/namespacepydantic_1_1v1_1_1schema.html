<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Objeto Inteligente - Sistema Completo: Referencia del espacio de nombres pydantic.v1.schema</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Objeto Inteligente - Sistema Completo<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Sistema de gestión de objetos inteligentes con ontologías, microservicios y automatización IoT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Buscar',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacepydantic_1_1v1_1_1schema.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Cargando...</div>
<div class="SRStatus" id="Searching">Buscando...</div>
<div class="SRStatus" id="NoMatches">Nada coincide</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Referencia del espacio de nombres pydantic.v1.schema</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Clases</h2></td></tr>
<tr class="memitem:SkipField" id="r_SkipField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpydantic_1_1v1_1_1schema_1_1_skip_field.html">SkipField</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Funciones</h2></td></tr>
<tr class="memitem:ae5c4de23840082adfe3871779fc1bc05" id="r_ae5c4de23840082adfe3871779fc1bc05"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5c4de23840082adfe3871779fc1bc05">_apply_modify_schema</a> (Callable[..., None] modify_schema, Optional[<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a>] field, Dict[str, Any] <a class="el" href="#a143b45ba59ca329472ebe1f79c84664c">field_schema</a>)</td></tr>
<tr class="memitem:af1605d68b9d7ea9b424a8c1d813e0d4b" id="r_af1605d68b9d7ea9b424a8c1d813e0d4b"><td class="memItemLeft" align="right" valign="top">Dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1605d68b9d7ea9b424a8c1d813e0d4b">schema</a> (Sequence[Union[Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>'], Type['<a class="el" href="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass.html">Dataclass</a>']]] <a class="el" href="namespacemodels.html">models</a>, *, bool by_alias=True, Optional[str] title=None, Optional[str] description=None, Optional[str] ref_prefix=None, str ref_template=<a class="el" href="#a45300e8762ca77ca25d632bddfe65d17">default_ref_template</a>)</td></tr>
<tr class="memitem:ada8725ffaa77dbd5ba12919e52700978" id="r_ada8725ffaa77dbd5ba12919e52700978"><td class="memItemLeft" align="right" valign="top">Dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada8725ffaa77dbd5ba12919e52700978">model_schema</a> (Union[Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>'], Type['<a class="el" href="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass.html">Dataclass</a>']] model, bool by_alias=True, Optional[str] ref_prefix=None, str ref_template=<a class="el" href="#a45300e8762ca77ca25d632bddfe65d17">default_ref_template</a>)</td></tr>
<tr class="memitem:a085485590e216879d83d4581c389caa1" id="r_a085485590e216879d83d4581c389caa1"><td class="memItemLeft" align="right" valign="top">Tuple[Dict[str, Any], bool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a085485590e216879d83d4581c389caa1">get_field_info_schema</a> (<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a> field, bool schema_overrides=False)</td></tr>
<tr class="memitem:a143b45ba59ca329472ebe1f79c84664c" id="r_a143b45ba59ca329472ebe1f79c84664c"><td class="memItemLeft" align="right" valign="top">Tuple[Dict[str, Any], Dict[str, Any], Set[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a143b45ba59ca329472ebe1f79c84664c">field_schema</a> (<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a> field, *, bool by_alias=True, Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str] model_name_map, Optional[str] ref_prefix=None, str ref_template=<a class="el" href="#a45300e8762ca77ca25d632bddfe65d17">default_ref_template</a>, Optional[<a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a>] known_models=None)</td></tr>
<tr class="memitem:a909fd2b9d3635e2cf96be73e3b0fbc4d" id="r_a909fd2b9d3635e2cf96be73e3b0fbc4d"><td class="memItemLeft" align="right" valign="top">Dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a909fd2b9d3635e2cf96be73e3b0fbc4d">get_field_schema_validations</a> (<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a> field)</td></tr>
<tr class="memitem:abb46ad06afd31a630a2dd723a7bff0e3" id="r_abb46ad06afd31a630a2dd723a7bff0e3"><td class="memItemLeft" align="right" valign="top">Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb46ad06afd31a630a2dd723a7bff0e3">get_model_name_map</a> (<a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> unique_models)</td></tr>
<tr class="memitem:aeda1bb0c53d768b6b96ebb3248dd5107" id="r_aeda1bb0c53d768b6b96ebb3248dd5107"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeda1bb0c53d768b6b96ebb3248dd5107">get_flat_models_from_model</a> (Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>'] model, Optional[<a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a>] known_models=None)</td></tr>
<tr class="memitem:a64092ecea8ee7d1b9cf182f1fc9bd7b1" id="r_a64092ecea8ee7d1b9cf182f1fc9bd7b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64092ecea8ee7d1b9cf182f1fc9bd7b1">get_flat_models_from_field</a> (<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a> field, <a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> known_models)</td></tr>
<tr class="memitem:a37a858129de8fba34d7a868de19e2e6e" id="r_a37a858129de8fba34d7a868de19e2e6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37a858129de8fba34d7a868de19e2e6e">get_flat_models_from_fields</a> (Sequence[<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a>] <a class="el" href="namespacepydantic_1_1v1_1_1fields.html">fields</a>, <a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> known_models)</td></tr>
<tr class="memitem:afa7208a83530a8ec66437d5890b8f814" id="r_afa7208a83530a8ec66437d5890b8f814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa7208a83530a8ec66437d5890b8f814">get_flat_models_from_models</a> (Sequence[Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>']] <a class="el" href="namespacemodels.html">models</a>)</td></tr>
<tr class="memitem:a9a6ed3513ddbdd7783e99282aac0e4d3" id="r_a9a6ed3513ddbdd7783e99282aac0e4d3"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a6ed3513ddbdd7783e99282aac0e4d3">get_long_model_name</a> (<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a> model)</td></tr>
<tr class="memitem:a4e385cef02d641ae49fca102d65adedd" id="r_a4e385cef02d641ae49fca102d65adedd"><td class="memItemLeft" align="right" valign="top">Tuple[Dict[str, Any], Dict[str, Any], Set[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e385cef02d641ae49fca102d65adedd">field_type_schema</a> (<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a> field, *, bool by_alias, Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str] model_name_map, str ref_template, bool schema_overrides=False, Optional[str] ref_prefix=None, <a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> known_models)</td></tr>
<tr class="memitem:af35f332620e82b46dc3716d336931da2" id="r_af35f332620e82b46dc3716d336931da2"><td class="memItemLeft" align="right" valign="top">Tuple[Dict[str, Any], Dict[str, Any], Set[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af35f332620e82b46dc3716d336931da2">model_process_schema</a> (<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a> model, *, bool by_alias=True, Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str] model_name_map, Optional[str] ref_prefix=None, str ref_template=<a class="el" href="#a45300e8762ca77ca25d632bddfe65d17">default_ref_template</a>, Optional[<a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a>] known_models=None, Optional[<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a>] field=None)</td></tr>
<tr class="memitem:a576c4e93e66916489138e89f961aecbf" id="r_a576c4e93e66916489138e89f961aecbf"><td class="memItemLeft" align="right" valign="top">Tuple[Dict[str, Any], Dict[str, Any], Set[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a576c4e93e66916489138e89f961aecbf">model_type_schema</a> (Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>'] model, *, bool by_alias, Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str] model_name_map, str ref_template, Optional[str] ref_prefix=None, <a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> known_models)</td></tr>
<tr class="memitem:a41af3271d8b4a90a26fa751433c59315" id="r_a41af3271d8b4a90a26fa751433c59315"><td class="memItemLeft" align="right" valign="top">Dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41af3271d8b4a90a26fa751433c59315">enum_process_schema</a> (Type[Enum] enum, *, Optional[<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a>] field=None)</td></tr>
<tr class="memitem:a21cb5357ace0ab92f28fec91025a9a0c" id="r_a21cb5357ace0ab92f28fec91025a9a0c"><td class="memItemLeft" align="right" valign="top">Tuple[Dict[str, Any], Dict[str, Any], Set[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21cb5357ace0ab92f28fec91025a9a0c">field_singleton_sub_fields_schema</a> (<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a> field, *, bool by_alias, Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str] model_name_map, str ref_template, bool schema_overrides=False, Optional[str] ref_prefix=None, <a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> known_models)</td></tr>
<tr class="memitem:a37d9cf3d1fa1b73d9fabe76d42ca841a" id="r_a37d9cf3d1fa1b73d9fabe76d42ca841a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37d9cf3d1fa1b73d9fabe76d42ca841a">add_field_type_to_schema</a> (Any field_type, Dict[str, Any] schema_)</td></tr>
<tr class="memitem:a044b24dafe5dd690889a1ef22bbf67ea" id="r_a044b24dafe5dd690889a1ef22bbf67ea"><td class="memItemLeft" align="right" valign="top">Dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a044b24dafe5dd690889a1ef22bbf67ea">get_schema_ref</a> (str name, Optional[str] ref_prefix, str ref_template, bool schema_overrides)</td></tr>
<tr class="memitem:a460a43ffebaffd19e79dfc4daa085bd9" id="r_a460a43ffebaffd19e79dfc4daa085bd9"><td class="memItemLeft" align="right" valign="top">Tuple[Dict[str, Any], Dict[str, Any], Set[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a460a43ffebaffd19e79dfc4daa085bd9">field_singleton_schema</a> (<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a> field, *, bool by_alias, Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str] model_name_map, str ref_template, bool schema_overrides=False, Optional[str] ref_prefix=None, <a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> known_models)</td></tr>
<tr class="memitem:a6cc715eb4e79a7160e1bd0e889793457" id="r_a6cc715eb4e79a7160e1bd0e889793457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cc715eb4e79a7160e1bd0e889793457">multitypes_literal_field_for_schema</a> (Tuple[Any,...] values, <a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a> field)</td></tr>
<tr class="memitem:aec25df6929d6a5074b37de352ca25bd1" id="r_aec25df6929d6a5074b37de352ca25bd1"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec25df6929d6a5074b37de352ca25bd1">encode_default</a> (Any dft)</td></tr>
<tr class="memitem:ad436a56e986536783b4b8f779a45fde1" id="r_ad436a56e986536783b4b8f779a45fde1"><td class="memItemLeft" align="right" valign="top">Type[Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad436a56e986536783b4b8f779a45fde1">get_annotation_from_field_info</a> (Any annotation, <a class="el" href="classpydantic_1_1v1_1_1fields_1_1_field_info.html">FieldInfo</a> field_info, str field_name, bool validate_assignment=False)</td></tr>
<tr class="memitem:a233ad4212b547e919249c343b07461ff" id="r_a233ad4212b547e919249c343b07461ff"><td class="memItemLeft" align="right" valign="top">Tuple[Type[Any], Set[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a233ad4212b547e919249c343b07461ff">get_annotation_with_constraints</a> (Any annotation, <a class="el" href="classpydantic_1_1v1_1_1fields_1_1_field_info.html">FieldInfo</a> field_info)</td></tr>
<tr class="memitem:a0852e5630819c67e4f94b861cf913633" id="r_a0852e5630819c67e4f94b861cf913633"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0852e5630819c67e4f94b861cf913633">normalize_name</a> (str name)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a77d416b7a1505e3c4348cdc3108a9111" id="r_a77d416b7a1505e3c4348cdc3108a9111"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77d416b7a1505e3c4348cdc3108a9111">default_prefix</a> = '#/definitions/'</td></tr>
<tr class="memitem:a45300e8762ca77ca25d632bddfe65d17" id="r_a45300e8762ca77ca25d632bddfe65d17"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45300e8762ca77ca25d632bddfe65d17">default_ref_template</a> = '#/definitions/{model}'</td></tr>
<tr class="memitem:a38cf70ba6a92a9a11519c3b391531562" id="r_a38cf70ba6a92a9a11519c3b391531562"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a> = Union[Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>'], Type[Enum]]</td></tr>
<tr class="memitem:a4e09ccd41882dceec2697c5ec244abd4" id="r_a4e09ccd41882dceec2697c5ec244abd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> = Set[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>]</td></tr>
<tr class="memitem:ab1557d12b18aef489c745889c513f6fe" id="r_ab1557d12b18aef489c745889c513f6fe"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1557d12b18aef489c745889c513f6fe">numeric_types</a> = (int, float, Decimal)</td></tr>
<tr class="memitem:a5014aa87ebcfcdae19bd3edf83d44384" id="r_a5014aa87ebcfcdae19bd3edf83d44384"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5014aa87ebcfcdae19bd3edf83d44384">_str_types_attrs</a></td></tr>
<tr class="memitem:afb1588105dd79c02cf4127b9501dadc6" id="r_afb1588105dd79c02cf4127b9501dadc6"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb1588105dd79c02cf4127b9501dadc6">_numeric_types_attrs</a></td></tr>
<tr class="memitem:af73de6125ab5061a98dd882840193719" id="r_af73de6125ab5061a98dd882840193719"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af73de6125ab5061a98dd882840193719">field_class_to_schema</a></td></tr>
<tr class="memitem:a9f4bf1706c3eea47f2cdb18b5bec448d" id="r_a9f4bf1706c3eea47f2cdb18b5bec448d"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f4bf1706c3eea47f2cdb18b5bec448d">json_scheme</a> = {'type': 'string', 'format': '<a class="el" href="namespacepydantic_1_1v1_1_1json.html">json</a>-string'}</td></tr>
<tr class="memitem:aae474cddbd5ce833975abb3dde048cad" id="r_aae474cddbd5ce833975abb3dde048cad"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae474cddbd5ce833975abb3dde048cad">_map_types_constraint</a> = {int: <a class="el" href="namespacepydantic_1_1v1_1_1types.html#ae283bf1c3c6e70e77940d4f2aa591d09">conint</a>, float: <a class="el" href="namespacepydantic_1_1v1_1_1types.html#af48f5141cd2ab347f2ecb4f097268d89">confloat</a>, Decimal: <a class="el" href="namespacepydantic_1_1v1_1_1types.html#a4595b5aec46d3fcf27917b69f86dad5d">condecimal</a>}</td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Documentación de funciones</h2>
<a id="ae5c4de23840082adfe3871779fc1bc05" name="ae5c4de23840082adfe3871779fc1bc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c4de23840082adfe3871779fc1bc05">&#9670;&#160;</a></span>_apply_modify_schema()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pydantic.v1.schema._apply_modify_schema </td>
          <td>(</td>
          <td class="paramtype">Callable[..., None]</td>          <td class="paramname"><span class="paramname"><em>modify_schema</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a>]</td>          <td class="paramname"><span class="paramname"><em>field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any]
</td>          <td class="paramname"><span class="paramname"><em>field_schema</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00096">96</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00655">enum_process_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00835">field_singleton_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00441">field_type_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00289">get_field_schema_validations()</a>.</p>

</div>
</div>
<a id="a37d9cf3d1fa1b73d9fabe76d42ca841a" name="a37d9cf3d1fa1b73d9fabe76d42ca841a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d9cf3d1fa1b73d9fabe76d42ca841a">&#9670;&#160;</a></span>add_field_type_to_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pydantic.v1.schema.add_field_type_to_schema </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>field_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any]</td>          <td class="paramname"><span class="paramname"><em>schema_</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Update the given `schema` with the type-specific metadata for the given `field_type`.

This function looks through `field_class_to_schema` for a class that matches the given `field_type`,
and then modifies the given `schema` with the information from that type.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00804">804</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00655">enum_process_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00835">field_singleton_schema()</a>.</p>

</div>
</div>
<a id="aec25df6929d6a5074b37de352ca25bd1" name="aec25df6929d6a5074b37de352ca25bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec25df6929d6a5074b37de352ca25bd1">&#9670;&#160;</a></span>encode_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any pydantic.v1.schema.encode_default </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>dft</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00976">976</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00976">encode_default()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00976">encode_default()</a> y <a class="el" href="v1_2schema_8py_source.html#l00200">get_field_info_schema()</a>.</p>

</div>
</div>
<a id="a41af3271d8b4a90a26fa751433c59315" name="a41af3271d8b4a90a26fa751433c59315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41af3271d8b4a90a26fa751433c59315">&#9670;&#160;</a></span>enum_process_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, Any] pydantic.v1.schema.enum_process_schema </td>
          <td>(</td>
          <td class="paramtype">Type[Enum]</td>          <td class="paramname"><span class="paramname"><em>enum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a>] </td>          <td class="paramname"><span class="paramname"><em>field</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Take a single `enum` and generate its schema.

This is similar to the `model_process_schema` function, but applies to ``Enum`` objects.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00655">655</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00098">_apply_modify_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00804">add_field_type_to_schema()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00835">field_singleton_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00560">model_process_schema()</a>.</p>

</div>
</div>
<a id="a143b45ba59ca329472ebe1f79c84664c" name="a143b45ba59ca329472ebe1f79c84664c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143b45ba59ca329472ebe1f79c84664c">&#9670;&#160;</a></span>field_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[Dict[str, Any], Dict[str, Any], Set[str]] pydantic.v1.schema.field_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>by_alias</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str]</td>          <td class="paramname"><span class="paramname"><em>model_name_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] </td>          <td class="paramname"><span class="paramname"><em>ref_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str </td>          <td class="paramname"><span class="paramname"><em>ref_template</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a45300e8762ca77ca25d632bddfe65d17">default_ref_template</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a>] </td>          <td class="paramname"><span class="paramname"><em>known_models</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Process a Pydantic field and return a tuple with a JSON Schema for it as the first item.
Also return a dictionary of definitions with models as keys and their schemas as values. If the passed field
is a model and has sub-models, and those sub-models don't have overrides (as ``title``, ``default``, etc), they
will be included in the definitions and referenced in the schema instead of included recursively.

:param field: a Pydantic ``ModelField``
:param by_alias: use the defined alias (if any) in the returned schema
:param model_name_map: used to generate the JSON Schema references to other models included in the definitions
:param ref_prefix: the JSON Pointer prefix to use for references to other schemas, if None, the default of
  #/definitions/ will be used
:param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful for
  references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For a
  sibling json file in a ``/schemas`` directory use ``"/schemas/${model}.json#"``.
:param known_models: used to solve circular references
:return: tuple of the schema for this field and additional definitions
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00222">222</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00441">field_type_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00200">get_field_info_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00289">get_field_schema_validations()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00835">field_singleton_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00609">model_type_schema()</a>.</p>

</div>
</div>
<a id="a460a43ffebaffd19e79dfc4daa085bd9" name="a460a43ffebaffd19e79dfc4daa085bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460a43ffebaffd19e79dfc4daa085bd9">&#9670;&#160;</a></span>field_singleton_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[Dict[str, Any], Dict[str, Any], Set[str]] pydantic.v1.schema.field_singleton_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_alias</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str]</td>          <td class="paramname"><span class="paramname"><em>model_name_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>ref_template</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>schema_overrides</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] </td>          <td class="paramname"><span class="paramname"><em>ref_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a></td>          <td class="paramname"><span class="paramname"><em>known_models</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function is indirectly used by ``field_schema()``, you should probably be using that function.

Take a single Pydantic ``ModelField``, and return its schema and any additional definitions from sub-models.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00826">826</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00098">_apply_modify_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00804">add_field_type_to_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00655">enum_process_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00230">field_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00690">field_singleton_sub_fields_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00200">get_field_info_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00818">get_schema_ref()</a>, <a class="el" href="v1_2schema_8py_source.html#l00560">model_process_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00954">multitypes_literal_field_for_schema()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00441">field_type_schema()</a>.</p>

</div>
</div>
<a id="a21cb5357ace0ab92f28fec91025a9a0c" name="a21cb5357ace0ab92f28fec91025a9a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cb5357ace0ab92f28fec91025a9a0c">&#9670;&#160;</a></span>field_singleton_sub_fields_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[Dict[str, Any], Dict[str, Any], Set[str]] pydantic.v1.schema.field_singleton_sub_fields_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_alias</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str]</td>          <td class="paramname"><span class="paramname"><em>model_name_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>ref_template</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>schema_overrides</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] </td>          <td class="paramname"><span class="paramname"><em>ref_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a></td>          <td class="paramname"><span class="paramname"><em>known_models</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function is indirectly used by ``field_schema()``, you probably should be using that function.

Take a list of Pydantic ``ModelField`` from the declaration of a type with parameters, and generate their
schema. I.e., fields used as "type parameters", like ``str`` and ``int`` in ``Tuple[str, int]``.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00681">681</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00441">field_type_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00818">get_schema_ref()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00835">field_singleton_schema()</a>.</p>

</div>
</div>
<a id="a4e385cef02d641ae49fca102d65adedd" name="a4e385cef02d641ae49fca102d65adedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e385cef02d641ae49fca102d65adedd">&#9670;&#160;</a></span>field_type_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[Dict[str, Any], Dict[str, Any], Set[str]] pydantic.v1.schema.field_type_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_alias</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str]</td>          <td class="paramname"><span class="paramname"><em>model_name_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>ref_template</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>schema_overrides</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] </td>          <td class="paramname"><span class="paramname"><em>ref_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a></td>          <td class="paramname"><span class="paramname"><em>known_models</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Used by ``field_schema()``, you probably should be using that function.

Take a single ``field`` and generate the schema for its type only, not including additional
information as title, etc. Also return additional schema definitions, from sub-models.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00432">432</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00098">_apply_modify_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00835">field_singleton_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00441">field_type_schema()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00230">field_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00690">field_singleton_sub_fields_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00441">field_type_schema()</a>.</p>

</div>
</div>
<a id="ad436a56e986536783b4b8f779a45fde1" name="ad436a56e986536783b4b8f779a45fde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad436a56e986536783b4b8f779a45fde1">&#9670;&#160;</a></span>get_annotation_from_field_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Type[Any] pydantic.v1.schema.get_annotation_from_field_info </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>annotation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1v1_1_1fields_1_1_field_info.html">FieldInfo</a></td>          <td class="paramname"><span class="paramname"><em>field_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>field_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>validate_assignment</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get an annotation with validation implemented for numbers and strings based on the field_info.
:param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``
:param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema
:param field_name: name of the field for use in error messages
:param validate_assignment: default False, flag for BaseModel Config value of validate_assignment
:return: the same ``annotation`` if unmodified or a new annotation with validation in place
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l01001">1001</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l01030">get_annotation_with_constraints()</a>.</p>

</div>
</div>
<a id="a233ad4212b547e919249c343b07461ff" name="a233ad4212b547e919249c343b07461ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233ad4212b547e919249c343b07461ff">&#9670;&#160;</a></span>get_annotation_with_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[Type[Any], Set[str]] pydantic.v1.schema.get_annotation_with_constraints </td>
          <td>(</td>
          <td class="paramtype">Any</td>          <td class="paramname"><span class="paramname"><em>annotation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1v1_1_1fields_1_1_field_info.html">FieldInfo</a></td>          <td class="paramname"><span class="paramname"><em>field_info</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get an annotation with used constraints implemented for numbers and strings based on the field_info.

:param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``
:param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema
:return: the same ``annotation`` if unmodified or a new annotation along with the used constraints.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l01030">1030</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="pydantic_2v1_2types_8py_source.html#l00564">pydantic.v1.types.confrozenset()</a>, <a class="el" href="pydantic_2v1_2types_8py_source.html#l00625">pydantic.v1.types.conlist()</a> y <a class="el" href="pydantic_2v1_2types_8py_source.html#l00520">pydantic.v1.types.conset()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l01003">get_annotation_from_field_info()</a>.</p>

</div>
</div>
<a id="a085485590e216879d83d4581c389caa1" name="a085485590e216879d83d4581c389caa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085485590e216879d83d4581c389caa1">&#9670;&#160;</a></span>get_field_info_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[Dict[str, Any], bool] pydantic.v1.schema.get_field_info_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>schema_overrides</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00200">200</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00976">encode_default()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00230">field_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00835">field_singleton_schema()</a>.</p>

</div>
</div>
<a id="a909fd2b9d3635e2cf96be73e3b0fbc4d" name="a909fd2b9d3635e2cf96be73e3b0fbc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909fd2b9d3635e2cf96be73e3b0fbc4d">&#9670;&#160;</a></span>get_field_schema_validations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, Any] pydantic.v1.schema.get_field_schema_validations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the JSON Schema validation keywords for a ``field`` with an annotation of
a Pydantic ``FieldInfo`` with validation arguments.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00289">289</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00098">_apply_modify_schema()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00230">field_schema()</a>.</p>

</div>
</div>
<a id="a64092ecea8ee7d1b9cf182f1fc9bd7b1" name="a64092ecea8ee7d1b9cf182f1fc9bd7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64092ecea8ee7d1b9cf182f1fc9bd7b1">&#9670;&#160;</a></span>get_flat_models_from_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> pydantic.v1.schema.get_flat_models_from_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a></td>          <td class="paramname"><span class="paramname"><em>known_models</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Take a single Pydantic ``ModelField`` (from a model) that could have been declared as a subclass of BaseModel
(so, it could be a submodel), and generate a set with its model and all the sub-models in the tree.
I.e. if you pass a field that was declared to be of type ``Foo`` (subclass of BaseModel) as ``field``, and that
model ``Foo`` has a field of type ``Bar`` (also subclass of ``BaseModel``) and that model ``Bar`` has a field of
type ``Baz`` (also subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``.

:param field: a Pydantic ``ModelField``
:param known_models: used to solve circular references
:return: a set with the model used in the declaration for this field, if any, and all its sub-models
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00369">369</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00398">get_flat_models_from_fields()</a> y <a class="el" href="v1_2schema_8py_source.html#l00349">get_flat_models_from_model()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00398">get_flat_models_from_fields()</a>.</p>

</div>
</div>
<a id="a37a858129de8fba34d7a868de19e2e6e" name="a37a858129de8fba34d7a868de19e2e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a858129de8fba34d7a868de19e2e6e">&#9670;&#160;</a></span>get_flat_models_from_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> pydantic.v1.schema.get_flat_models_from_fields </td>
          <td>(</td>
          <td class="paramtype">Sequence[<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a>]</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a></td>          <td class="paramname"><span class="paramname"><em>known_models</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Take a list of Pydantic  ``ModelField``s (from a model) that could have been declared as subclasses of ``BaseModel``
(so, any of them could be a submodel), and generate a set with their models and all the sub-models in the tree.
I.e. if you pass a the fields of a model ``Foo`` (subclass of ``BaseModel``) as ``fields``, and on of them has a
field of type ``Bar`` (also subclass of ``BaseModel``) and that model ``Bar`` has a field of type ``Baz`` (also
subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``.

:param fields: a list of Pydantic ``ModelField``s
:param known_models: used to solve circular references
:return: a set with any model declared in the fields, and all their sub-models
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00398">398</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00369">get_flat_models_from_field()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00369">get_flat_models_from_field()</a> y <a class="el" href="v1_2schema_8py_source.html#l00349">get_flat_models_from_model()</a>.</p>

</div>
</div>
<a id="aeda1bb0c53d768b6b96ebb3248dd5107" name="aeda1bb0c53d768b6b96ebb3248dd5107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda1bb0c53d768b6b96ebb3248dd5107">&#9670;&#160;</a></span>get_flat_models_from_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> pydantic.v1.schema.get_flat_models_from_model </td>
          <td>(</td>
          <td class="paramtype">Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>']</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a>] </td>          <td class="paramname"><span class="paramname"><em>known_models</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Take a single ``model`` and generate a set with itself and all the sub-models in the tree. I.e. if you pass
model ``Foo`` (subclass of Pydantic ``BaseModel``) as ``model``, and it has a field of type ``Bar`` (also
subclass of ``BaseModel``) and that model ``Bar`` has a field of type ``Baz`` (also subclass of ``BaseModel``),
the return value will be ``set([Foo, Bar, Baz])``.

:param model: a Pydantic ``BaseModel`` subclass
:param known_models: used to solve circular references
:return: a set with the initial model and all its sub-models
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00349">349</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00398">get_flat_models_from_fields()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00369">get_flat_models_from_field()</a>, <a class="el" href="v1_2schema_8py_source.html#l00416">get_flat_models_from_models()</a> y <a class="el" href="v1_2schema_8py_source.html#l00167">model_schema()</a>.</p>

</div>
</div>
<a id="afa7208a83530a8ec66437d5890b8f814" name="afa7208a83530a8ec66437d5890b8f814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7208a83530a8ec66437d5890b8f814">&#9670;&#160;</a></span>get_flat_models_from_models()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a> pydantic.v1.schema.get_flat_models_from_models </td>
          <td>(</td>
          <td class="paramtype">Sequence[Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>']]</td>          <td class="paramname"><span class="paramname"><em>models</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Take a list of ``models`` and generate a set with them and all their sub-models in their trees. I.e. if you pass
a list of two models, ``Foo`` and ``Bar``, both subclasses of Pydantic ``BaseModel`` as models, and ``Bar`` has
a field of type ``Baz`` (also subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00416">416</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00349">get_flat_models_from_model()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00117">schema()</a>.</p>

</div>
</div>
<a id="a9a6ed3513ddbdd7783e99282aac0e4d3" name="a9a6ed3513ddbdd7783e99282aac0e4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6ed3513ddbdd7783e99282aac0e4d3">&#9670;&#160;</a></span>get_long_model_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str pydantic.v1.schema.get_long_model_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a></td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00428">428</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00322">get_model_name_map()</a>.</p>

</div>
</div>
<a id="abb46ad06afd31a630a2dd723a7bff0e3" name="abb46ad06afd31a630a2dd723a7bff0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb46ad06afd31a630a2dd723a7bff0e3">&#9670;&#160;</a></span>get_model_name_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str] pydantic.v1.schema.get_model_name_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a></td>          <td class="paramname"><span class="paramname"><em>unique_models</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Process a set of models and generate unique names for them to be used as keys in the JSON Schema
definitions. By default the names are the same as the class name. But if two models in different Python
modules have the same name (e.g. "users.Model" and "items.Model"), the generated names will be
based on the Python module path for those conflicting models to prevent name collisions.

:param unique_models: a Python set of models
:return: dict mapping models to names
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00322">322</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00428">get_long_model_name()</a> y <a class="el" href="v1_2schema_8py_source.html#l01150">normalize_name()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00167">model_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00117">schema()</a>.</p>

</div>
</div>
<a id="a044b24dafe5dd690889a1ef22bbf67ea" name="a044b24dafe5dd690889a1ef22bbf67ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044b24dafe5dd690889a1ef22bbf67ea">&#9670;&#160;</a></span>get_schema_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, Any] pydantic.v1.schema.get_schema_ref </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str]</td>          <td class="paramname"><span class="paramname"><em>ref_prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>ref_template</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>schema_overrides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00818">818</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00835">field_singleton_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00690">field_singleton_sub_fields_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00167">model_schema()</a>.</p>

</div>
</div>
<a id="af35f332620e82b46dc3716d336931da2" name="af35f332620e82b46dc3716d336931da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35f332620e82b46dc3716d336931da2">&#9670;&#160;</a></span>model_process_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[Dict[str, Any], Dict[str, Any], Set[str]] pydantic.v1.schema.model_process_schema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a></td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>by_alias</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str]</td>          <td class="paramname"><span class="paramname"><em>model_name_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] </td>          <td class="paramname"><span class="paramname"><em>ref_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str </td>          <td class="paramname"><span class="paramname"><em>ref_template</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a45300e8762ca77ca25d632bddfe65d17">default_ref_template</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a>] </td>          <td class="paramname"><span class="paramname"><em>known_models</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[<a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a>] </td>          <td class="paramname"><span class="paramname"><em>field</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Used by ``model_schema()``, you probably should be using that function.

Take a single ``model`` and generate its schema. Also return additional schema definitions, from sub-models. The
sub-models of the returned schema will be referenced, but their definitions will not be included in the schema. All
the definitions are returned as the second value.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00551">551</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00655">enum_process_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00609">model_type_schema()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00835">field_singleton_schema()</a>, <a class="el" href="v1_2schema_8py_source.html#l00167">model_schema()</a> y <a class="el" href="v1_2schema_8py_source.html#l00117">schema()</a>.</p>

</div>
</div>
<a id="ada8725ffaa77dbd5ba12919e52700978" name="ada8725ffaa77dbd5ba12919e52700978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8725ffaa77dbd5ba12919e52700978">&#9670;&#160;</a></span>model_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, Any] pydantic.v1.schema.model_schema </td>
          <td>(</td>
          <td class="paramtype">Union[Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>'], Type['<a class="el" href="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass.html">Dataclass</a>']]</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>by_alias</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] </td>          <td class="paramname"><span class="paramname"><em>ref_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str </td>          <td class="paramname"><span class="paramname"><em>ref_template</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a45300e8762ca77ca25d632bddfe65d17">default_ref_template</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a JSON Schema for one model. With all the sub-models defined in the ``definitions`` top-level
JSON key.

:param model: a Pydantic model (a class that inherits from BaseModel)
:param by_alias: generate the schemas using the aliases defined, if any
:param ref_prefix: the JSON Pointer prefix for schema references with ``$ref``, if None, will be set to the
  default of ``#/definitions/``. Update it if you want the schemas to reference the definitions somewhere
  else, e.g. for OpenAPI use ``#/components/schemas/``. The resulting generated schemas will still be at the
  top-level key ``definitions``, so you can extract them from there. But all the references will have the set
  prefix.
:param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful for
  references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For a
  sibling json file in a ``/schemas`` directory use ``"/schemas/${model}.json#"``.
:return: dict with the JSON Schema for the passed ``model``
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00162">162</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00349">get_flat_models_from_model()</a>, <a class="el" href="v1_2schema_8py_source.html#l00322">get_model_name_map()</a>, <a class="el" href="v1_2schema_8py_source.html#l00818">get_schema_ref()</a> y <a class="el" href="v1_2schema_8py_source.html#l00560">model_process_schema()</a>.</p>

</div>
</div>
<a id="a576c4e93e66916489138e89f961aecbf" name="a576c4e93e66916489138e89f961aecbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576c4e93e66916489138e89f961aecbf">&#9670;&#160;</a></span>model_type_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[Dict[str, Any], Dict[str, Any], Set[str]] pydantic.v1.schema.model_type_schema </td>
          <td>(</td>
          <td class="paramtype">Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>']</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_alias</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>, str]</td>          <td class="paramname"><span class="paramname"><em>model_name_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>ref_template</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] </td>          <td class="paramname"><span class="paramname"><em>ref_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4e09ccd41882dceec2697c5ec244abd4">TypeModelSet</a></td>          <td class="paramname"><span class="paramname"><em>known_models</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">You probably should be using ``model_schema()``, this function is indirectly used by that function.

Take a single ``model`` and generate the schema for its type only, not including additional
information as title, etc. Also return additional schema definitions, from sub-models.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00601">601</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00230">field_schema()</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00560">model_process_schema()</a>.</p>

</div>
</div>
<a id="a6cc715eb4e79a7160e1bd0e889793457" name="a6cc715eb4e79a7160e1bd0e889793457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc715eb4e79a7160e1bd0e889793457">&#9670;&#160;</a></span>multitypes_literal_field_for_schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a> pydantic.v1.schema.multitypes_literal_field_for_schema </td>
          <td>(</td>
          <td class="paramtype">Tuple[Any, ...]</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpydantic_1_1v1_1_1fields_1_1_model_field.html">ModelField</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">To support `Literal` with values of different types, we split it into multiple `Literal` with same type
e.g. `Literal['qwe', 'asd', 1, 2]` becomes `Union[Literal['qwe', 'asd'], Literal[1, 2]]`
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00954">954</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00835">field_singleton_schema()</a>.</p>

</div>
</div>
<a id="a0852e5630819c67e4f94b861cf913633" name="a0852e5630819c67e4f94b861cf913633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0852e5630819c67e4f94b861cf913633">&#9670;&#160;</a></span>normalize_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str pydantic.v1.schema.normalize_name </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Normalizes the given name. This can be applied to either a model *or* enum.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l01150">1150</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Referenciado por <a class="el" href="v1_2schema_8py_source.html#l00322">get_model_name_map()</a>.</p>

</div>
</div>
<a id="af1605d68b9d7ea9b424a8c1d813e0d4b" name="af1605d68b9d7ea9b424a8c1d813e0d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1605d68b9d7ea9b424a8c1d813e0d4b">&#9670;&#160;</a></span>schema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, Any] pydantic.v1.schema.schema </td>
          <td>(</td>
          <td class="paramtype">Sequence[Union[Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>'], Type['<a class="el" href="classpydantic_1_1v1_1_1dataclasses_1_1_dataclass.html">Dataclass</a>']]]</td>          <td class="paramname"><span class="paramname"><em>models</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>by_alias</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] </td>          <td class="paramname"><span class="paramname"><em>title</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] </td>          <td class="paramname"><span class="paramname"><em>description</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] </td>          <td class="paramname"><span class="paramname"><em>ref_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str </td>          <td class="paramname"><span class="paramname"><em>ref_template</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a45300e8762ca77ca25d632bddfe65d17">default_ref_template</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Process a list of models and generate a single JSON Schema with all of them defined in the ``definitions``
top-level JSON key, including their sub-models.

:param models: a list of models to include in the generated JSON Schema
:param by_alias: generate the schemas using the aliases defined, if any
:param title: title for the generated schema that includes the definitions
:param description: description for the generated schema
:param ref_prefix: the JSON Pointer prefix for schema references with ``$ref``, if None, will be set to the
  default of ``#/definitions/``. Update it if you want the schemas to reference the definitions somewhere
  else, e.g. for OpenAPI use ``#/components/schemas/``. The resulting generated schemas will still be at the
  top-level key ``definitions``, so you can extract them from there. But all the references will have the set
  prefix.
:param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful
  for references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For
  a sibling json file in a ``/schemas`` directory use ``"/schemas/${model}.json#"``.
:return: dict with the JSON Schema with a ``definitions`` top-level key including the schema definitions for
  the models and sub-models passed in ``models``.
</pre> 
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00109">109</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

<p class="reference">Hace referencia a <a class="el" href="v1_2schema_8py_source.html#l00416">get_flat_models_from_models()</a>, <a class="el" href="v1_2schema_8py_source.html#l00322">get_model_name_map()</a> y <a class="el" href="v1_2schema_8py_source.html#l00560">model_process_schema()</a>.</p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Documentación de variables</h2>
<a id="aae474cddbd5ce833975abb3dde048cad" name="aae474cddbd5ce833975abb3dde048cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae474cddbd5ce833975abb3dde048cad">&#9670;&#160;</a></span>_map_types_constraint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict pydantic.v1.schema._map_types_constraint = {int: <a class="el" href="namespacepydantic_1_1v1_1_1types.html#ae283bf1c3c6e70e77940d4f2aa591d09">conint</a>, float: <a class="el" href="namespacepydantic_1_1v1_1_1types.html#af48f5141cd2ab347f2ecb4f097268d89">confloat</a>, Decimal: <a class="el" href="namespacepydantic_1_1v1_1_1types.html#a4595b5aec46d3fcf27917b69f86dad5d">condecimal</a>}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00998">998</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

</div>
</div>
<a id="afb1588105dd79c02cf4127b9501dadc6" name="afb1588105dd79c02cf4127b9501dadc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1588105dd79c02cf4127b9501dadc6">&#9670;&#160;</a></span>_numeric_types_attrs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple pydantic.v1.schema._numeric_types_attrs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Valor inicial:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  (</div>
<div class="line"><span class="lineno">    2</span>    (<span class="stringliteral">&#39;gt&#39;</span>, numeric_types, <span class="stringliteral">&#39;exclusiveMinimum&#39;</span>),</div>
<div class="line"><span class="lineno">    3</span>    (<span class="stringliteral">&#39;lt&#39;</span>, numeric_types, <span class="stringliteral">&#39;exclusiveMaximum&#39;</span>),</div>
<div class="line"><span class="lineno">    4</span>    (<span class="stringliteral">&#39;ge&#39;</span>, numeric_types, <span class="stringliteral">&#39;minimum&#39;</span>),</div>
<div class="line"><span class="lineno">    5</span>    (<span class="stringliteral">&#39;le&#39;</span>, numeric_types, <span class="stringliteral">&#39;maximum&#39;</span>),</div>
<div class="line"><span class="lineno">    6</span>    (<span class="stringliteral">&#39;multiple_of&#39;</span>, numeric_types, <span class="stringliteral">&#39;multipleOf&#39;</span>),</div>
<div class="line"><span class="lineno">    7</span>)</div>
</div><!-- fragment -->
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00280">280</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

</div>
</div>
<a id="a5014aa87ebcfcdae19bd3edf83d44384" name="a5014aa87ebcfcdae19bd3edf83d44384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5014aa87ebcfcdae19bd3edf83d44384">&#9670;&#160;</a></span>_str_types_attrs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple pydantic.v1.schema._str_types_attrs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Valor inicial:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  (</div>
<div class="line"><span class="lineno">    2</span>    (<span class="stringliteral">&#39;max_length&#39;</span>, numeric_types, <span class="stringliteral">&#39;maxLength&#39;</span>),</div>
<div class="line"><span class="lineno">    3</span>    (<span class="stringliteral">&#39;min_length&#39;</span>, numeric_types, <span class="stringliteral">&#39;minLength&#39;</span>),</div>
<div class="line"><span class="lineno">    4</span>    (<span class="stringliteral">&#39;regex&#39;</span>, str, <span class="stringliteral">&#39;pattern&#39;</span>),</div>
<div class="line"><span class="lineno">    5</span>)</div>
</div><!-- fragment -->
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00274">274</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

</div>
</div>
<a id="a77d416b7a1505e3c4348cdc3108a9111" name="a77d416b7a1505e3c4348cdc3108a9111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d416b7a1505e3c4348cdc3108a9111">&#9670;&#160;</a></span>default_prefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str pydantic.v1.schema.default_prefix = '#/definitions/'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00089">89</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

</div>
</div>
<a id="a45300e8762ca77ca25d632bddfe65d17" name="a45300e8762ca77ca25d632bddfe65d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45300e8762ca77ca25d632bddfe65d17">&#9670;&#160;</a></span>default_ref_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str pydantic.v1.schema.default_ref_template = '#/definitions/{model}'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00090">90</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

</div>
</div>
<a id="af73de6125ab5061a98dd882840193719" name="af73de6125ab5061a98dd882840193719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73de6125ab5061a98dd882840193719">&#9670;&#160;</a></span>field_class_to_schema</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple pydantic.v1.schema.field_class_to_schema</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Valor inicial:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  (</div>
<div class="line"><span class="lineno">    2</span>    (Path, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;path&#39;</span>}),</div>
<div class="line"><span class="lineno">    3</span>    (datetime, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;date-time&#39;</span>}),</div>
<div class="line"><span class="lineno">    4</span>    (date, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;date&#39;</span>}),</div>
<div class="line"><span class="lineno">    5</span>    (time, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;time&#39;</span>}),</div>
<div class="line"><span class="lineno">    6</span>    (timedelta, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;number&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;time-delta&#39;</span>}),</div>
<div class="line"><span class="lineno">    7</span>    (IPv4Network, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;ipv4network&#39;</span>}),</div>
<div class="line"><span class="lineno">    8</span>    (IPv6Network, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;ipv6network&#39;</span>}),</div>
<div class="line"><span class="lineno">    9</span>    (IPv4Interface, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;ipv4interface&#39;</span>}),</div>
<div class="line"><span class="lineno">   10</span>    (IPv6Interface, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;ipv6interface&#39;</span>}),</div>
<div class="line"><span class="lineno">   11</span>    (IPv4Address, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;ipv4&#39;</span>}),</div>
<div class="line"><span class="lineno">   12</span>    (IPv6Address, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;ipv6&#39;</span>}),</div>
<div class="line"><span class="lineno">   13</span>    (Pattern, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;regex&#39;</span>}),</div>
<div class="line"><span class="lineno">   14</span>    (str, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>}),</div>
<div class="line"><span class="lineno">   15</span>    (bytes, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;binary&#39;</span>}),</div>
<div class="line"><span class="lineno">   16</span>    (bool, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;boolean&#39;</span>}),</div>
<div class="line"><span class="lineno">   17</span>    (int, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;integer&#39;</span>}),</div>
<div class="line"><span class="lineno">   18</span>    (float, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;number&#39;</span>}),</div>
<div class="line"><span class="lineno">   19</span>    (Decimal, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;number&#39;</span>}),</div>
<div class="line"><span class="lineno">   20</span>    (UUID, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;format&#39;</span>: <span class="stringliteral">&#39;uuid&#39;</span>}),</div>
<div class="line"><span class="lineno">   21</span>    (dict, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;object&#39;</span>}),</div>
<div class="line"><span class="lineno">   22</span>    (list, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;array&#39;</span>, <span class="stringliteral">&#39;items&#39;</span>: {}}),</div>
<div class="line"><span class="lineno">   23</span>    (tuple, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;array&#39;</span>, <span class="stringliteral">&#39;items&#39;</span>: {}}),</div>
<div class="line"><span class="lineno">   24</span>    (set, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;array&#39;</span>, <span class="stringliteral">&#39;items&#39;</span>: {}, <span class="stringliteral">&#39;uniqueItems&#39;</span>: <span class="keyword">True</span>}),</div>
<div class="line"><span class="lineno">   25</span>    (frozenset, {<span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;array&#39;</span>, <span class="stringliteral">&#39;items&#39;</span>: {}, <span class="stringliteral">&#39;uniqueItems&#39;</span>: <span class="keyword">True</span>}),</div>
<div class="line"><span class="lineno">   26</span>)</div>
</div><!-- fragment -->
<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00774">774</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

</div>
</div>
<a id="a9f4bf1706c3eea47f2cdb18b5bec448d" name="a9f4bf1706c3eea47f2cdb18b5bec448d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4bf1706c3eea47f2cdb18b5bec448d">&#9670;&#160;</a></span>json_scheme</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict pydantic.v1.schema.json_scheme = {'type': 'string', 'format': '<a class="el" href="namespacepydantic_1_1v1_1_1json.html">json</a>-string'}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00801">801</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

</div>
</div>
<a id="ab1557d12b18aef489c745889c513f6fe" name="ab1557d12b18aef489c745889c513f6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1557d12b18aef489c745889c513f6fe">&#9670;&#160;</a></span>numeric_types</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple pydantic.v1.schema.numeric_types = (int, float, Decimal)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00273">273</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

</div>
</div>
<a id="a38cf70ba6a92a9a11519c3b391531562" name="a38cf70ba6a92a9a11519c3b391531562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cf70ba6a92a9a11519c3b391531562">&#9670;&#160;</a></span>TypeModelOrEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic.v1.schema.TypeModelOrEnum = Union[Type['<a class="el" href="classpydantic_1_1v1_1_1main_1_1_base_model.html">BaseModel</a>'], Type[Enum]]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00092">92</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

</div>
</div>
<a id="a4e09ccd41882dceec2697c5ec244abd4" name="a4e09ccd41882dceec2697c5ec244abd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e09ccd41882dceec2697c5ec244abd4">&#9670;&#160;</a></span>TypeModelSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pydantic.v1.schema.TypeModelSet = Set[<a class="el" href="#a38cf70ba6a92a9a11519c3b391531562">TypeModelOrEnum</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="v1_2schema_8py_source.html#l00093">93</a> del archivo <a class="el" href="v1_2schema_8py_source.html">schema.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacepydantic.html">pydantic</a></li><li class="navelem"><a href="namespacepydantic_1_1v1.html">v1</a></li><li class="navelem"><a href="namespacepydantic_1_1v1_1_1schema.html">schema</a></li>
    <li class="footer">Generado el <span class="timestamp"></span> para Objeto Inteligente - Sistema Completo por <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>

\doxysection{Referencia de la clase setuptools.\+\_\+vendor.\+typing\+\_\+extensions.\+Protocol}
\hypertarget{classsetuptools_1_1__vendor_1_1typing__extensions_1_1_protocol}{}\label{classsetuptools_1_1__vendor_1_1typing__extensions_1_1_protocol}\index{setuptools.\_vendor.typing\_extensions.Protocol@{setuptools.\_vendor.typing\_extensions.Protocol}}


Diagrama de herencia de setuptools.\+\_\+vendor.\+typing\+\_\+extensions.\+Protocol
% FIG 0


Diagrama de colaboración de setuptools.\+\_\+vendor.\+typing\+\_\+extensions.\+Protocol\+:
% FIG 1
\doxysubsubsection*{Otros miembros heredados}
\doxysubsection*{Atributos protegidos heredados de \mbox{\hyperlink{classsetuptools_1_1__vendor_1_1typing__extensions_1_1___protocol_meta}{setuptools.\+\_\+vendor.\+typing\+\_\+extensions.\+\_\+\+Protocol\+Meta}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classsetuptools_1_1__vendor_1_1typing__extensions_1_1___protocol_meta_a418f8bbc476e97fc0276d4e17b60200f}{\+\_\+is\+\_\+protocol}}
\item 
\mbox{\hyperlink{classsetuptools_1_1__vendor_1_1typing__extensions_1_1___protocol_meta_a76b1d830bde91b50364ade2e3192d974}{\+\_\+abc\+\_\+registry}} = origin.\+\_\+abc\+\_\+registry
\item 
\mbox{\hyperlink{classsetuptools_1_1__vendor_1_1typing__extensions_1_1___protocol_meta_a5c529190b18d2e00d0c36065c28403bf}{\+\_\+abc\+\_\+cache}} = origin.\+\_\+abc\+\_\+cache
\end{DoxyCompactItemize}


\doxysubsection{Descripción detallada}
\begin{DoxyVerb}Base class for protocol classes. Protocol classes are defined as::

    class Proto(Protocol):
        def meth(self) -> int:
            ...

Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::

    class C:
        def meth(self) -> int:
            return 0

    def func(x: Proto) -> int:
        return x.meth()

    func(C())  # Passes static type check

See PEP 544 for details. Protocol classes decorated with
@typing_extensions.runtime act as simple-minded runtime protocol that checks
only the presence of given attributes, ignoring their type signatures.

Protocol classes can be generic, they are defined as::

    class GenProto(Protocol[T]):
        def meth(self) -> T:
            ...
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{microservicio__data__stream_2venv_2_lib_2site-packages_2setuptools_2__vendor_2typing__extensions_8py_source_l00539}{539}} del archivo \mbox{\hyperlink{microservicio__data__stream_2venv_2_lib_2site-packages_2setuptools_2__vendor_2typing__extensions_8py_source}{typing\+\_\+extensions.\+py}}.



La documentación de esta clase está generada del siguiente archivo\+:\begin{DoxyCompactItemize}
\item 
microservicio\+\_\+data\+\_\+stream/venv/\+Lib/site-\/packages/setuptools/\+\_\+vendor/\mbox{\hyperlink{microservicio__data__stream_2venv_2_lib_2site-packages_2setuptools_2__vendor_2typing__extensions_8py}{typing\+\_\+extensions.\+py}}\end{DoxyCompactItemize}

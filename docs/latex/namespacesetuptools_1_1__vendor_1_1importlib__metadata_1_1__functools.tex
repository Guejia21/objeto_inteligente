\doxysection{Referencia del espacio de nombres setuptools.\+\_\+vendor.\+importlib\+\_\+metadata.\+\_\+functools}
\hypertarget{namespacesetuptools_1_1__vendor_1_1importlib__metadata_1_1__functools}{}\label{namespacesetuptools_1_1__vendor_1_1importlib__metadata_1_1__functools}\index{setuptools.\_vendor.importlib\_metadata.\_functools@{setuptools.\_vendor.importlib\_metadata.\_functools}}
\doxysubsubsection*{Funciones}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesetuptools_1_1__vendor_1_1importlib__metadata_1_1__functools_a6cfe43e1a6e24560a5d64ef66ef08296}{method\+\_\+cache}} (method, cache\+\_\+wrapper=None)
\item 
\mbox{\hyperlink{namespacesetuptools_1_1__vendor_1_1importlib__metadata_1_1__functools_a9e39741414cfa20ba3219d1cbdc2d0f3}{pass\+\_\+none}} (func)
\end{DoxyCompactItemize}


\label{doc-func-members}
\Hypertarget{namespacesetuptools_1_1__vendor_1_1importlib__metadata_1_1__functools_doc-func-members}
\doxysubsection{Documentación de funciones}
\Hypertarget{namespacesetuptools_1_1__vendor_1_1importlib__metadata_1_1__functools_a6cfe43e1a6e24560a5d64ef66ef08296}\index{setuptools.\_vendor.importlib\_metadata.\_functools@{setuptools.\_vendor.importlib\_metadata.\_functools}!method\_cache@{method\_cache}}
\index{method\_cache@{method\_cache}!setuptools.\_vendor.importlib\_metadata.\_functools@{setuptools.\_vendor.importlib\_metadata.\_functools}}
\doxysubsubsection{\texorpdfstring{method\_cache()}{method\_cache()}}
{\footnotesize\ttfamily \label{namespacesetuptools_1_1__vendor_1_1importlib__metadata_1_1__functools_a6cfe43e1a6e24560a5d64ef66ef08296} 
setuptools.\+\_\+vendor.\+importlib\+\_\+metadata.\+\_\+functools.\+method\+\_\+cache (\begin{DoxyParamCaption}\item[{}]{method}{, }\item[{}]{cache\+\_\+wrapper}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Wrap lru_cache to support storing the cache data in the object instances.

Abstracts the common paradigm where the method explicitly saves an
underscore-prefixed protected property on first call and returns that
subsequently.

>>> class MyClass:
...     calls = 0
...
...     @method_cache
...     def method(self, value):
...         self.calls += 1
...         return value

>>> a = MyClass()
>>> a.method(3)
3
>>> for x in range(75):
...     res = a.method(x)
>>> a.calls
75

Note that the apparent behavior will be exactly like that of lru_cache
except that the cache is stored on each instance, so values in one
instance will not flush values from another, and when an instance is
deleted, so are the cached values for that instance.

>>> b = MyClass()
>>> for x in range(35):
...     res = b.method(x)
>>> b.calls
35
>>> a.method(0)
0
>>> a.calls
75

Note that if method had been decorated with ``functools.lru_cache()``,
a.calls would have been 76 (due to the cached value of 0 having been
flushed by the 'b' instance).

Clear the cache with ``.cache_clear()``

>>> a.method.cache_clear()

Same for a method that hasn't yet been called.

>>> c = MyClass()
>>> c.method.cache_clear()

Another cache wrapper may be supplied:

>>> cache = functools.lru_cache(maxsize=2)
>>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)
>>> a = MyClass()
>>> a.method2()
3

Caution - do not subsequently wrap the method with another decorator, such
as ``@property``, which changes the semantics of the function.

See also
http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/
for another implementation and additional justification.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__vendor_2importlib__metadata_2__functools_8py_source_l00006}{6}} del archivo \mbox{\hyperlink{__vendor_2importlib__metadata_2__functools_8py_source}{\+\_\+functools.\+py}}.

\Hypertarget{namespacesetuptools_1_1__vendor_1_1importlib__metadata_1_1__functools_a9e39741414cfa20ba3219d1cbdc2d0f3}\index{setuptools.\_vendor.importlib\_metadata.\_functools@{setuptools.\_vendor.importlib\_metadata.\_functools}!pass\_none@{pass\_none}}
\index{pass\_none@{pass\_none}!setuptools.\_vendor.importlib\_metadata.\_functools@{setuptools.\_vendor.importlib\_metadata.\_functools}}
\doxysubsubsection{\texorpdfstring{pass\_none()}{pass\_none()}}
{\footnotesize\ttfamily \label{namespacesetuptools_1_1__vendor_1_1importlib__metadata_1_1__functools_a9e39741414cfa20ba3219d1cbdc2d0f3} 
setuptools.\+\_\+vendor.\+importlib\+\_\+metadata.\+\_\+functools.\+pass\+\_\+none (\begin{DoxyParamCaption}\item[{}]{func}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Wrap func so it's not called if its first param is None

>>> print_text = pass_none(print)
>>> print_text('text')
text
>>> print_text(None)
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__vendor_2importlib__metadata_2__functools_8py_source_l00089}{89}} del archivo \mbox{\hyperlink{__vendor_2importlib__metadata_2__functools_8py_source}{\+\_\+functools.\+py}}.


\doxysection{Referencia del espacio de nombres pydantic.\+\_\+internal.\+\_\+dataclasses}
\hypertarget{namespacepydantic_1_1__internal_1_1__dataclasses}{}\label{namespacepydantic_1_1__internal_1_1__dataclasses}\index{pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}}
\doxysubsubsection*{Clases}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classpydantic_1_1__internal_1_1__dataclasses_1_1_pydantic_dataclass}{Pydantic\+Dataclass}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Funciones}
\begin{DoxyCompactItemize}
\item 
None \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__dataclasses_a77eed25ad21231d8c11cbad890b97af3}{set\+\_\+dataclass\+\_\+fields}} (type\mbox{[}Standard\+Dataclass\mbox{]} cls, \mbox{\hyperlink{classpydantic_1_1__internal_1_1__config_1_1_config_wrapper}{\+\_\+config.\+Config\+Wrapper}} config\+\_\+wrapper, \mbox{\hyperlink{classpydantic_1_1__internal_1_1__namespace__utils_1_1_ns_resolver}{Ns\+Resolver}}\texorpdfstring{$\vert$}{|}None ns\+\_\+resolver=None)
\item 
bool \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__dataclasses_a266847a42d1b54567f4b4359c9fb26ed}{complete\+\_\+dataclass}} (type\mbox{[}Any\mbox{]} cls, \mbox{\hyperlink{classpydantic_1_1__internal_1_1__config_1_1_config_wrapper}{\+\_\+config.\+Config\+Wrapper}} config\+\_\+wrapper, \texorpdfstring{$\ast$}{*}, bool raise\+\_\+errors=True, \mbox{\hyperlink{classpydantic_1_1__internal_1_1__namespace__utils_1_1_ns_resolver}{Ns\+Resolver}}\texorpdfstring{$\vert$}{|}None ns\+\_\+resolver=None, bool \+\_\+force\+\_\+build=False)
\item 
Type\+Is\mbox{[}type\mbox{[}Standard\+Dataclass\mbox{]}\mbox{]} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__dataclasses_abe60dd98b99019ccb86633f79fe59bcf}{is\+\_\+stdlib\+\_\+dataclass}} (type\mbox{[}Any\mbox{]} cls)
\item 
dataclasses.\+Field\mbox{[}Any\mbox{]} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__dataclasses_ade5001444c71ee8ffa4dbfc3ee7b53e4}{as\+\_\+dataclass\+\_\+field}} (\mbox{\hyperlink{classpydantic_1_1fields_1_1_field_info}{Field\+Info}} pydantic\+\_\+field)
\item 
Generator\mbox{[}None\mbox{]} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__dataclasses_aba47473eb4d2b0ab0a942e0cc308dc2e}{patch\+\_\+base\+\_\+fields}} (type\mbox{[}Any\mbox{]} cls)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
Type\+Alias \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__dataclasses_a0bbfc838259f236ad6761daa81835363}{Dc\+Fields}} = dict\mbox{[}str, dataclasses.\+Field\mbox{[}Any\mbox{]}\mbox{]}
\end{DoxyCompactItemize}


\doxysubsection{Descripción detallada}
\begin{DoxyVerb}Private logic for creating pydantic dataclasses.\end{DoxyVerb}
 

\label{doc-func-members}
\Hypertarget{namespacepydantic_1_1__internal_1_1__dataclasses_doc-func-members}
\doxysubsection{Documentación de funciones}
\Hypertarget{namespacepydantic_1_1__internal_1_1__dataclasses_ade5001444c71ee8ffa4dbfc3ee7b53e4}\index{pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}!as\_dataclass\_field@{as\_dataclass\_field}}
\index{as\_dataclass\_field@{as\_dataclass\_field}!pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}}
\doxysubsubsection{\texorpdfstring{as\_dataclass\_field()}{as\_dataclass\_field()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__dataclasses_ade5001444c71ee8ffa4dbfc3ee7b53e4} 
 dataclasses.\+Field\mbox{[}Any\mbox{]} pydantic.\+\_\+internal.\+\_\+dataclasses.\+as\+\_\+dataclass\+\_\+field (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classpydantic_1_1fields_1_1_field_info}{Field\+Info}}}]{pydantic\+\_\+field}{}\end{DoxyParamCaption})}



Definición en la línea \mbox{\hyperlink{__dataclasses_8py_source_l00208}{208}} del archivo \mbox{\hyperlink{__dataclasses_8py_source}{\+\_\+dataclasses.\+py}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__dataclasses_a266847a42d1b54567f4b4359c9fb26ed}\index{pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}!complete\_dataclass@{complete\_dataclass}}
\index{complete\_dataclass@{complete\_dataclass}!pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}}
\doxysubsubsection{\texorpdfstring{complete\_dataclass()}{complete\_dataclass()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__dataclasses_a266847a42d1b54567f4b4359c9fb26ed} 
 bool pydantic.\+\_\+internal.\+\_\+dataclasses.\+complete\+\_\+dataclass (\begin{DoxyParamCaption}\item[{type\mbox{[}Any\mbox{]}}]{cls}{, }\item[{\mbox{\hyperlink{classpydantic_1_1__internal_1_1__config_1_1_config_wrapper}{\+\_\+config.\+Config\+Wrapper}}}]{config\+\_\+wrapper}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{bool }]{raise\+\_\+errors}{ = {\ttfamily True}, }\item[{\mbox{\hyperlink{classpydantic_1_1__internal_1_1__namespace__utils_1_1_ns_resolver}{Ns\+Resolver}} \texorpdfstring{$\vert$}{|} None }]{ns\+\_\+resolver}{ = {\ttfamily None}, }\item[{bool }]{\+\_\+force\+\_\+build}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Finish building a pydantic dataclass.

This logic is called on a class which has already been wrapped in `dataclasses.dataclass()`.

This is somewhat analogous to `pydantic._internal._model_construction.complete_model_class`.

Args:
    cls: The class.
    config_wrapper: The config wrapper instance.
    raise_errors: Whether to raise errors, defaults to `True`.
    ns_resolver: The namespace resolver instance to use when collecting dataclass fields
        and during schema building.
    _force_build: Whether to force building the dataclass, no matter if
        [`defer_build`][pydantic.config.ConfigDict.defer_build] is set.

Returns:
    `True` if building a pydantic dataclass is successfully completed, `False` otherwise.

Raises:
    PydanticUndefinedAnnotation: If `raise_error` is `True` and there is an undefined annotations.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__dataclasses_8py_source_l00085}{85}} del archivo \mbox{\hyperlink{__dataclasses_8py_source}{\+\_\+dataclasses.\+py}}.



Hace referencia a \mbox{\hyperlink{__dataclasses_8py_source_l00069}{set\+\_\+dataclass\+\_\+fields()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__dataclasses_abe60dd98b99019ccb86633f79fe59bcf}\index{pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}!is\_stdlib\_dataclass@{is\_stdlib\_dataclass}}
\index{is\_stdlib\_dataclass@{is\_stdlib\_dataclass}!pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}}
\doxysubsubsection{\texorpdfstring{is\_stdlib\_dataclass()}{is\_stdlib\_dataclass()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__dataclasses_abe60dd98b99019ccb86633f79fe59bcf} 
 Type\+Is\mbox{[}type\mbox{[}Standard\+Dataclass\mbox{]}\mbox{]} pydantic.\+\_\+internal.\+\_\+dataclasses.\+is\+\_\+stdlib\+\_\+dataclass (\begin{DoxyParamCaption}\item[{type\mbox{[}Any\mbox{]}}]{cls}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns `True` if the class is a stdlib dataclass and *not* a Pydantic dataclass.

Unlike the stdlib `dataclasses.is_dataclass()` function, this does *not* include subclasses
of a dataclass that are themselves not dataclasses.

Args:
    cls: The class.

Returns:
    `True` if the class is a stdlib dataclass, `False` otherwise.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__dataclasses_8py_source_l00193}{193}} del archivo \mbox{\hyperlink{__dataclasses_8py_source}{\+\_\+dataclasses.\+py}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__dataclasses_aba47473eb4d2b0ab0a942e0cc308dc2e}\index{pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}!patch\_base\_fields@{patch\_base\_fields}}
\index{patch\_base\_fields@{patch\_base\_fields}!pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}}
\doxysubsubsection{\texorpdfstring{patch\_base\_fields()}{patch\_base\_fields()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__dataclasses_aba47473eb4d2b0ab0a942e0cc308dc2e} 
 Generator\mbox{[}None\mbox{]} pydantic.\+\_\+internal.\+\_\+dataclasses.\+patch\+\_\+base\+\_\+fields (\begin{DoxyParamCaption}\item[{type\mbox{[}Any\mbox{]}}]{cls}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Temporarily patch the stdlib dataclasses bases of `cls` if the Pydantic `Field()` function is used.

When creating a Pydantic dataclass, it is possible to inherit from stdlib dataclasses, where
the Pydantic `Field()` function is used. To create this Pydantic dataclass, we first apply
the stdlib `@dataclass` decorator on it. During the construction of the stdlib dataclass,
the `kw_only` and `repr` field arguments need to be understood by the stdlib *during* the
dataclass construction. To do so, we temporarily patch the fields dictionary of the affected
bases.

For instance, with the following example:

```python {test="skip" lint="skip"}
import dataclasses as stdlib_dc

import pydantic
import pydantic.dataclasses as pydantic_dc

@stdlib_dc.dataclass
class A:
    a: int = pydantic.Field(repr=False)

# Notice that the `repr` attribute of the dataclass field is `True`:
A.__dataclass_fields__['a']
#> dataclass.Field(default=FieldInfo(repr=False), repr=True, ...)

@pydantic_dc.dataclass
class B(A):
    b: int = pydantic.Field(repr=False)
```

When passing `B` to the stdlib `@dataclass` decorator, it will look for fields in the parent classes
and reuse them directly. When this context manager is active, `A` will be temporarily patched to be
equivalent to:

```python {test="skip" lint="skip"}
@stdlib_dc.dataclass
class A:
    a: int = stdlib_dc.field(default=Field(repr=False), repr=False)
```

!!! note
    This is only applied to the bases of `cls`, and not `cls` itself. The reason is that the Pydantic
    dataclass decorator "owns" `cls` (in the previous example, `B`). As such, we instead modify the fields
    directly (in the previous example, we simply do `setattr(B, 'b', as_dataclass_field(pydantic_field))`).

!!! note
    This approach is far from ideal, and can probably be the source of unwanted side effects/race conditions.
    The previous implemented approach was mutating the `__annotations__` dict of `cls`, which is no longer a
    safe operation in Python 3.14+, and resulted in unexpected behavior with field ordering anyway.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__dataclasses_8py_source_l00230}{230}} del archivo \mbox{\hyperlink{__dataclasses_8py_source}{\+\_\+dataclasses.\+py}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__dataclasses_a77eed25ad21231d8c11cbad890b97af3}\index{pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}!set\_dataclass\_fields@{set\_dataclass\_fields}}
\index{set\_dataclass\_fields@{set\_dataclass\_fields}!pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}}
\doxysubsubsection{\texorpdfstring{set\_dataclass\_fields()}{set\_dataclass\_fields()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__dataclasses_a77eed25ad21231d8c11cbad890b97af3} 
 None pydantic.\+\_\+internal.\+\_\+dataclasses.\+set\+\_\+dataclass\+\_\+fields (\begin{DoxyParamCaption}\item[{type\mbox{[}Standard\+Dataclass\mbox{]}}]{cls}{, }\item[{\mbox{\hyperlink{classpydantic_1_1__internal_1_1__config_1_1_config_wrapper}{\+\_\+config.\+Config\+Wrapper}}}]{config\+\_\+wrapper}{, }\item[{\mbox{\hyperlink{classpydantic_1_1__internal_1_1__namespace__utils_1_1_ns_resolver}{Ns\+Resolver}} \texorpdfstring{$\vert$}{|} None }]{ns\+\_\+resolver}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Collect and set `cls.__pydantic_fields__`.

Args:
    cls: The class.
    config_wrapper: The config wrapper instance.
    ns_resolver: Namespace resolver to use when getting dataclass annotations.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__dataclasses_8py_source_l00065}{65}} del archivo \mbox{\hyperlink{__dataclasses_8py_source}{\+\_\+dataclasses.\+py}}.



Referenciado por \mbox{\hyperlink{__dataclasses_8py_source_l00092}{complete\+\_\+dataclass()}}.



\label{doc-var-members}
\Hypertarget{namespacepydantic_1_1__internal_1_1__dataclasses_doc-var-members}
\doxysubsection{Documentación de variables}
\Hypertarget{namespacepydantic_1_1__internal_1_1__dataclasses_a0bbfc838259f236ad6761daa81835363}\index{pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}!DcFields@{DcFields}}
\index{DcFields@{DcFields}!pydantic.\_internal.\_dataclasses@{pydantic.\_internal.\_dataclasses}}
\doxysubsubsection{\texorpdfstring{DcFields}{DcFields}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__dataclasses_a0bbfc838259f236ad6761daa81835363} 
Type\+Alias pydantic.\+\_\+internal.\+\_\+dataclasses.\+Dc\+Fields = dict\mbox{[}str, dataclasses.\+Field\mbox{[}Any\mbox{]}\mbox{]}}



Definición en la línea \mbox{\hyperlink{__dataclasses_8py_source_l00226}{226}} del archivo \mbox{\hyperlink{__dataclasses_8py_source}{\+\_\+dataclasses.\+py}}.


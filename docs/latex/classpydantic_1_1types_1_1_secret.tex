\doxysection{Referencia de la clase pydantic.\+types.\+Secret}
\hypertarget{classpydantic_1_1types_1_1_secret}{}\label{classpydantic_1_1types_1_1_secret}\index{pydantic.types.Secret@{pydantic.types.Secret}}


Diagrama de herencia de pydantic.\+types.\+Secret
% FIG 0


Diagrama de colaboración de pydantic.\+types.\+Secret\+:
% FIG 1
\doxysubsubsection*{Métodos protegidos}
\begin{DoxyCompactItemize}
\item 
str\texorpdfstring{$\vert$}{|}bytes \mbox{\hyperlink{classpydantic_1_1types_1_1_secret_ab2cf7615d9a1658513fdbf03bbb9f645}{\+\_\+display}} (self)
\end{DoxyCompactItemize}
\doxysubsubsection*{Otros miembros heredados}
\doxysubsection*{Métodos públicos heredados de \mbox{\hyperlink{classpydantic_1_1types_1_1___secret_base}{pydantic.\+types.\+\_\+\+Secret\+Base}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacepydantic_1_1types_a8676a2acab10c93a2f3dacfd036e040b}{Secret\+Type}} \mbox{\hyperlink{classpydantic_1_1types_1_1___secret_base_abf935019390ef527c632459c6a429541}{get\+\_\+secret\+\_\+value}} (self)
\end{DoxyCompactItemize}
\doxysubsection*{Atributos protegidos heredados de \mbox{\hyperlink{classpydantic_1_1types_1_1___secret_base}{pydantic.\+types.\+\_\+\+Secret\+Base}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacepydantic_1_1types_a8676a2acab10c93a2f3dacfd036e040b}{Secret\+Type}} \mbox{\hyperlink{classpydantic_1_1types_1_1___secret_base_a63be8193bebc4f78975c1439bc89581f}{\+\_\+secret\+\_\+value}} = secret\+\_\+value
\end{DoxyCompactItemize}


\doxysubsection{Descripción detallada}
\begin{DoxyVerb}A generic base class used for defining a field with sensitive information that you do not want to be visible in logging or tracebacks.

You may either directly parametrize `Secret` with a type, or subclass from `Secret` with a parametrized type. The benefit of subclassing
is that you can define a custom `_display` method, which will be used for `repr()` and `str()` methods. The examples below demonstrate both
ways of using `Secret` to create a new secret type.

1. Directly parametrizing `Secret` with a type:

```python
from pydantic import BaseModel, Secret

SecretBool = Secret[bool]

class Model(BaseModel):
    secret_bool: SecretBool

m = Model(secret_bool=True)
print(m.model_dump())
#> {'secret_bool': Secret('**********')}

print(m.model_dump_json())
#> {"secret_bool":"**********"}

print(m.secret_bool.get_secret_value())
#> True
```

2. Subclassing from parametrized `Secret`:

```python
from datetime import date

from pydantic import BaseModel, Secret

class SecretDate(Secret[date]):
    def _display(self) -> str:
        return '****/**/**'

class Model(BaseModel):
    secret_date: SecretDate

m = Model(secret_date=date(2022, 1, 1))
print(m.model_dump())
#> {'secret_date': SecretDate('****/**/**')}

print(m.model_dump_json())
#> {"secret_date":"****/**/**"}

print(m.secret_date.get_secret_value())
#> 2022-01-01
```

The value returned by the `_display` method will be used for `repr()` and `str()`.

You can enforce constraints on the underlying type through annotations:
For example:

```python
from typing import Annotated

from pydantic import BaseModel, Field, Secret, ValidationError

SecretPosInt = Secret[Annotated[int, Field(gt=0, strict=True)]]

class Model(BaseModel):
    sensitive_int: SecretPosInt

m = Model(sensitive_int=42)
print(m.model_dump())
#> {'sensitive_int': Secret('**********')}

try:
    m = Model(sensitive_int=-42)  # (1)!
except ValidationError as exc_info:
    print(exc_info.errors(include_url=False, include_input=False))
    '''
    [
        {
            'type': 'greater_than',
            'loc': ('sensitive_int',),
            'msg': 'Input should be greater than 0',
            'ctx': {'gt': 0},
        }
    ]
    '''

try:
    m = Model(sensitive_int='42')  # (2)!
except ValidationError as exc_info:
    print(exc_info.errors(include_url=False, include_input=False))
    '''
    [
        {
            'type': 'int_type',
            'loc': ('sensitive_int',),
            'msg': 'Input should be a valid integer',
        }
    ]
    '''
```

1. The input value is not greater than 0, so it raises a validation error.
2. The input value is not an integer, so it raises a validation error because the `SecretPosInt` type has strict mode enabled.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{pydantic_2types_8py_source_l01571}{1571}} del archivo \mbox{\hyperlink{pydantic_2types_8py_source}{types.\+py}}.



\label{doc-func-members}
\Hypertarget{classpydantic_1_1types_1_1_secret_doc-func-members}
\doxysubsection{Documentación de funciones miembro}
\Hypertarget{classpydantic_1_1types_1_1_secret_ab2cf7615d9a1658513fdbf03bbb9f645}\index{pydantic.types.Secret@{pydantic.types.Secret}!\_display@{\_display}}
\index{\_display@{\_display}!pydantic.types.Secret@{pydantic.types.Secret}}
\doxysubsubsection{\texorpdfstring{\_display()}{\_display()}}
{\footnotesize\ttfamily \label{classpydantic_1_1types_1_1_secret_ab2cf7615d9a1658513fdbf03bbb9f645} 
 str \texorpdfstring{$\vert$}{|} bytes pydantic.\+types.\+Secret.\+\_\+display (\begin{DoxyParamCaption}\item[{}]{self}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Reimplementado de \mbox{\hyperlink{classpydantic_1_1types_1_1___secret_base_ae79c1c705b9ef693122dd95102abff2e}{pydantic.\+types.\+\_\+\+Secret\+Base}}.



Definición en la línea \mbox{\hyperlink{pydantic_2types_8py_source_l01677}{1677}} del archivo \mbox{\hyperlink{pydantic_2types_8py_source}{types.\+py}}.



Hace referencia a \mbox{\hyperlink{pydantic_2types_8py_source_l01540}{pydantic.\+types.\+\_\+\+Secret\+Base.\+get\+\_\+secret\+\_\+value()}}.



La documentación de esta clase está generada del siguiente archivo\+:\begin{DoxyCompactItemize}
\item 
micro\+\_\+gestion\+\_\+objetos/venv/\+Lib/site-\/packages/pydantic/\mbox{\hyperlink{pydantic_2types_8py}{types.\+py}}\end{DoxyCompactItemize}

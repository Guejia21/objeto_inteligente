\doxysection{Referencia del archivo micro\+\_\+gestion\+\_\+objetos/venv/\+Lib/site-\/packages/fastapi/encoders.py}
\hypertarget{encoders_8py}{}\label{encoders_8py}\index{micro\_gestion\_objetos/venv/Lib/site-\/packages/fastapi/encoders.py@{micro\_gestion\_objetos/venv/Lib/site-\/packages/fastapi/encoders.py}}
\doxysubsubsection*{Espacios de nombres}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespacefastapi}{fastapi}}
\item 
namespace \mbox{\hyperlink{namespacefastapi_1_1encoders}{fastapi.\+encoders}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Funciones}
\begin{DoxyCompactItemize}
\item 
str \mbox{\hyperlink{namespacefastapi_1_1encoders_adc00caffad917a29ab1ddd390179cd16}{fastapi.\+encoders.\+isoformat}} (Union\mbox{[}datetime.\+date, datetime.\+time\mbox{]} o)
\item 
Union\mbox{[}int, float\mbox{]} \mbox{\hyperlink{namespacefastapi_1_1encoders_ab81304164f23fec1ec418cda53a73aff}{fastapi.\+encoders.\+decimal\+\_\+encoder}} (Decimal dec\+\_\+value)
\item 
Dict\mbox{[}Callable\mbox{[}\mbox{[}Any\mbox{]}, Any\mbox{]}, Tuple\mbox{[}Any,...\mbox{]}\mbox{]} \mbox{\hyperlink{namespacefastapi_1_1encoders_af2180d0b94f700332a7a579eb623dbbc}{fastapi.\+encoders.\+generate\+\_\+encoders\+\_\+by\+\_\+class\+\_\+tuples}} (Dict\mbox{[}Any, Callable\mbox{[}\mbox{[}Any\mbox{]}, Any\mbox{]}\mbox{]} type\+\_\+encoder\+\_\+map)
\item 
Any \mbox{\hyperlink{namespacefastapi_1_1encoders_a01f88c4c0f37eccf17f85c88d8442217}{fastapi.\+encoders.\+jsonable\+\_\+encoder}} (Annotated\mbox{[}Any, \mbox{\hyperlink{classtyping__extensions_1_1_doc}{Doc}}("{}"{}"{}            The input object to convert to JSON.            "{}"{}"{}),\mbox{]} obj, Annotated\mbox{[}Optional\mbox{[}Inc\+Ex\mbox{]}, \mbox{\hyperlink{classtyping__extensions_1_1_doc}{Doc}}("{}"{}"{}            Pydantic\textquotesingle{}s \`{}include\`{} parameter, passed to Pydantic \mbox{\hyperlink{namespacemodels}{models}} to set the            fields to include.            "{}"{}"{}),\mbox{]} include=None, Annotated\mbox{[}Optional\mbox{[}Inc\+Ex\mbox{]}, \mbox{\hyperlink{classtyping__extensions_1_1_doc}{Doc}}("{}"{}"{}            Pydantic\textquotesingle{}s \`{}exclude\`{} parameter, passed to Pydantic \mbox{\hyperlink{namespacemodels}{models}} to set the            fields to exclude.            "{}"{}"{}),\mbox{]} exclude=None, Annotated\mbox{[}bool, \mbox{\hyperlink{classtyping__extensions_1_1_doc}{Doc}}("{}"{}"{}            Pydantic\textquotesingle{}s \`{}by\+\_\+alias\`{} parameter, passed to Pydantic \mbox{\hyperlink{namespacemodels}{models}} to define if            the output should use the alias names (when provided) or the Python            attribute names. In an API, if you set an alias, it\textquotesingle{}s probably because you            want to use it in the result, so you probably want to leave this set to            \`{}True\`{}.            "{}"{}"{}),\mbox{]} by\+\_\+alias=True, Annotated\mbox{[}bool, \mbox{\hyperlink{classtyping__extensions_1_1_doc}{Doc}}("{}"{}"{}            Pydantic\textquotesingle{}s \`{}exclude\+\_\+unset\`{} parameter, passed to Pydantic \mbox{\hyperlink{namespacemodels}{models}} to define            if it should exclude from the output the fields that were not explicitly            set (and that only had their default values).            "{}"{}"{}),\mbox{]} exclude\+\_\+unset=False, Annotated\mbox{[}bool, \mbox{\hyperlink{classtyping__extensions_1_1_doc}{Doc}}("{}"{}"{}            Pydantic\textquotesingle{}s \`{}exclude\+\_\+defaults\`{} parameter, passed to Pydantic \mbox{\hyperlink{namespacemodels}{models}} to define            if it should exclude from the output the fields that had the same default            value, even when they were explicitly set.            "{}"{}"{}),\mbox{]} exclude\+\_\+defaults=False, Annotated\mbox{[}bool, \mbox{\hyperlink{classtyping__extensions_1_1_doc}{Doc}}("{}"{}"{}            Pydantic\textquotesingle{}s \`{}exclude\+\_\+none\`{} parameter, passed to Pydantic \mbox{\hyperlink{namespacemodels}{models}} to define            if it should exclude from the output any fields that have a \`{}None\`{} value.            "{}"{}"{}),\mbox{]} exclude\+\_\+none=False, Annotated\mbox{[}Optional\mbox{[}Dict\mbox{[}Any, Callable\mbox{[}\mbox{[}Any\mbox{]}, Any\mbox{]}\mbox{]}\mbox{]}, \mbox{\hyperlink{classtyping__extensions_1_1_doc}{Doc}}("{}"{}"{}            Pydantic\textquotesingle{}s \`{}custom\+\_\+encoder\`{} parameter, passed to Pydantic \mbox{\hyperlink{namespacemodels}{models}} to define            a custom encoder.            "{}"{}"{}),\mbox{]} custom\+\_\+encoder=None, Annotated\mbox{[}bool, \mbox{\hyperlink{classtyping__extensions_1_1_doc}{Doc}}("{}"{}"{}            Exclude from the output any fields that start with the name \`{}\+\_\+sa\`{}.            This is mainly a hack for compatibility with SQLAlchemy objects, they            store internal SQLAlchemy-\/specific state in attributes named with \`{}\+\_\+sa\`{},            and those objects can\textquotesingle{}t (and shouldn\textquotesingle{}t be) serialized to JSON.            "{}"{}"{}),\mbox{]} sqlalchemy\+\_\+safe=True)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
dict \mbox{\hyperlink{namespacefastapi_1_1encoders_a9d3ac854ddb7d858ddadec56a684650a}{fastapi.\+encoders.\+ENCODERS\+\_\+\+BY\+\_\+\+TYPE}}
\item 
Dict\mbox{[}Callable\mbox{[}\mbox{[}Any\mbox{]}, Any\mbox{]}, Tuple\mbox{[}Any,...\mbox{]}\mbox{]} \mbox{\hyperlink{namespacefastapi_1_1encoders_a5a98e69228eeee5991f24422cc7c97bc}{fastapi.\+encoders.\+encoders\+\_\+by\+\_\+class\+\_\+tuples}} = \mbox{\hyperlink{namespacefastapi_1_1encoders_af2180d0b94f700332a7a579eb623dbbc}{generate\+\_\+encoders\+\_\+by\+\_\+class\+\_\+tuples}}(\mbox{\hyperlink{namespacefastapi_1_1encoders_a9d3ac854ddb7d858ddadec56a684650a}{ENCODERS\+\_\+\+BY\+\_\+\+TYPE}})
\end{DoxyCompactItemize}

\doxysection{Referencia del espacio de nombres pydantic.\+\_\+internal.\+\_\+generics}
\hypertarget{namespacepydantic_1_1__internal_1_1__generics}{}\label{namespacepydantic_1_1__internal_1_1__generics}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection*{Clases}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classpydantic_1_1__internal_1_1__generics_1_1_limited_dict}{Limited\+Dict}}
\item 
class \mbox{\hyperlink{classpydantic_1_1__internal_1_1__generics_1_1_deep_chain_map}{Deep\+Chain\+Map}}
\item 
class \mbox{\hyperlink{classpydantic_1_1__internal_1_1__generics_1_1_pydantic_generic_metadata}{Pydantic\+Generic\+Metadata}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Funciones}
\begin{DoxyCompactItemize}
\item 
type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_afcded858103d896453101e13b29d2a9b}{create\+\_\+generic\+\_\+submodel}} (str model\+\_\+name, type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} origin, tuple\mbox{[}Any,...\mbox{]} args, tuple\mbox{[}Any,...\mbox{]} params)
\item 
tuple\mbox{[}str\texorpdfstring{$\vert$}{|}None, bool\mbox{]} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a79b21e519e79b1218b1f3d652fa33b1d}{\+\_\+get\+\_\+caller\+\_\+frame\+\_\+info}} (int depth=2)
\item 
Iterator\mbox{[}Type\+Var\mbox{]} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a91e72b4bc6889cef434bb6ffd83d61bc}{iter\+\_\+contained\+\_\+typevars}} (Any v)
\item 
Any \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a29a07a03dba4ccf370007eb6718cd7b9}{get\+\_\+args}} (Any v)
\item 
Any \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a71145b763a2bc45e77b2f646d9d365b5}{get\+\_\+origin}} (Any v)
\item 
dict\mbox{[}Type\+Var, Any\mbox{]}\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_ae5f63b9cae8e839cd0f0237583dd02c8}{get\+\_\+standard\+\_\+typevars\+\_\+map}} (Any cls)
\item 
dict\mbox{[}Type\+Var, Any\mbox{]} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_af8dab9794ade8386bed3975ec7a1c3f8}{get\+\_\+model\+\_\+typevars\+\_\+map}} (type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} cls)
\item 
Any \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_abf393e8a431474b872c9096a8e99fadd}{replace\+\_\+types}} (Any type\+\_\+, Mapping\mbox{[}Type\+Var, Any\mbox{]}\texorpdfstring{$\vert$}{|}None type\+\_\+map)
\item 
dict\mbox{[}Type\+Var, Any\mbox{]} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a988383c2fcc5e45381e7a3246650d212}{map\+\_\+generic\+\_\+model\+\_\+arguments}} (type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} cls, tuple\mbox{[}Any,...\mbox{]} args)
\item 
Iterator\mbox{[}\mbox{\hyperlink{classpydantic_1_1__internal_1_1__forward__ref_1_1_pydantic_recursive_ref}{Pydantic\+Recursive\+Ref}}\texorpdfstring{$\vert$}{|}None\mbox{]} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a05b120c91cf4df0a83a1cea779288b53}{generic\+\_\+recursion\+\_\+self\+\_\+type}} (type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} origin, tuple\mbox{[}Any,...\mbox{]} args)
\item 
set\mbox{[}str\mbox{]} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a58e6abceadaad8d39b24555f71afe7d9}{recursively\+\_\+defined\+\_\+type\+\_\+refs}} ()
\item 
type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a3c9314192feecb986c1a784369b212fa}{get\+\_\+cached\+\_\+generic\+\_\+type\+\_\+early}} (type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} parent, Any typevar\+\_\+values)
\item 
type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a1c055e35886a98db1334e04fc60f8be0}{get\+\_\+cached\+\_\+generic\+\_\+type\+\_\+late}} (type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} parent, Any typevar\+\_\+values, type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} origin, tuple\mbox{[}Any,...\mbox{]} args)
\item 
None \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_ac46c5b5c5c2d0a221f8cda82b25ae9c0}{set\+\_\+cached\+\_\+generic\+\_\+type}} (type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} parent, tuple\mbox{[}Any,...\mbox{]} typevar\+\_\+values, type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} type\+\_\+, type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}\texorpdfstring{$\vert$}{|}None origin=None, tuple\mbox{[}Any,...\mbox{]}\texorpdfstring{$\vert$}{|}None args=None)
\item 
Any \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_ad1b2be56fbba991bdca0c593c464a6c2}{\+\_\+union\+\_\+orderings\+\_\+key}} (Any typevar\+\_\+values)
\item 
\mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_af66dce654d9513143523a13ddec1ff64}{Generic\+Types\+Cache\+Key}} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a0b982a936af6d27a669a64ff44d55fc4}{\+\_\+early\+\_\+cache\+\_\+key}} (type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} cls, Any typevar\+\_\+values)
\item 
\mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_af66dce654d9513143523a13ddec1ff64}{Generic\+Types\+Cache\+Key}} \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a58fb0be9dd993d6b0c1659091ca30716}{\+\_\+late\+\_\+cache\+\_\+key}} (type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} origin, tuple\mbox{[}Any,...\mbox{]} args, Any typevar\+\_\+values)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_af66dce654d9513143523a13ddec1ff64}{Generic\+Types\+Cache\+Key}} = tuple\mbox{[}Any, Any, tuple\mbox{[}Any, ...\mbox{]}\mbox{]}
\item 
\mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a9105fc49941fc60b0585824ef933bd48}{KT}} = Type\+Var(\textquotesingle{}KT\textquotesingle{})
\item 
\mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a041e256fadbac3133f8d1c4dab1df1f2}{VT}} = Type\+Var(\textquotesingle{}VT\textquotesingle{})
\item 
int \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_ab0a4726777265f7ae662e5519a732e5b}{\+\_\+\+LIMITED\+\_\+\+DICT\+\_\+\+SIZE}} = 100
\item 
\mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a39a759bcb29ba97f166450d257693259}{Generic\+Types\+Cache}} = Weak\+Value\+Dictionary\mbox{[}\mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_af66dce654d9513143523a13ddec1ff64}{Generic\+Types\+Cache\+Key}}, \textquotesingle{}type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}\textquotesingle{}\mbox{]}
\item 
dict \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_ac482f3da5f4edd52b0b458c5a729c253}{Dict\+Values}} = \{\}.values().\+\_\+\+\_\+class\+\_\+\+\_\+
\item 
Context\+Var \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_a852f427cbedb8cfd7cf488f2ffef9c18}{\+\_\+generic\+\_\+recursion\+\_\+cache}} = Context\+Var(\textquotesingle{}\+\_\+generic\+\_\+recursion\+\_\+cache\textquotesingle{}, default=None)
\end{DoxyCompactItemize}


\label{doc-func-members}
\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_doc-func-members}
\doxysubsection{Documentación de funciones}
\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a0b982a936af6d27a669a64ff44d55fc4}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!\_early\_cache\_key@{\_early\_cache\_key}}
\index{\_early\_cache\_key@{\_early\_cache\_key}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{\_early\_cache\_key()}{\_early\_cache\_key()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a0b982a936af6d27a669a64ff44d55fc4} 
 \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_af66dce654d9513143523a13ddec1ff64}{Generic\+Types\+Cache\+Key}} pydantic.\+\_\+internal.\+\_\+generics.\+\_\+early\+\_\+cache\+\_\+key (\begin{DoxyParamCaption}\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}}]{cls}{, }\item[{Any}]{typevar\+\_\+values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}This is intended for minimal computational overhead during lookups of cached types.

Note that this is overly simplistic, and it's possible that two different cls/typevar_values
inputs would ultimately result in the same type being created in BaseModel.__class_getitem__.
To handle this, we have a fallback _late_cache_key that is checked later if the _early_cache_key
lookup fails, and should result in a cache hit _precisely_ when the inputs to __class_getitem__
would result in the same type.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00522}{522}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00501}{\+\_\+union\+\_\+orderings\+\_\+key()}}.



Referenciado por \mbox{\hyperlink{__generics_8py_source_l00438}{get\+\_\+cached\+\_\+generic\+\_\+type\+\_\+early()}} y \mbox{\hyperlink{__generics_8py_source_l00484}{set\+\_\+cached\+\_\+generic\+\_\+type()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a79b21e519e79b1218b1f3d652fa33b1d}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!\_get\_caller\_frame\_info@{\_get\_caller\_frame\_info}}
\index{\_get\_caller\_frame\_info@{\_get\_caller\_frame\_info}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{\_get\_caller\_frame\_info()}{\_get\_caller\_frame\_info()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a79b21e519e79b1218b1f3d652fa33b1d} 
 tuple\mbox{[}str \texorpdfstring{$\vert$}{|} None, bool\mbox{]} pydantic.\+\_\+internal.\+\_\+generics.\+\_\+get\+\_\+caller\+\_\+frame\+\_\+info (\begin{DoxyParamCaption}\item[{int }]{depth}{ = {\ttfamily 2}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Used inside a function to check whether it was called globally.

Args:
    depth: The depth to get the frame.

Returns:
    A tuple contains `module_name` and `called_globally`.

Raises:
    RuntimeError: If the function is not called inside a function.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00152}{152}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Referenciado por \mbox{\hyperlink{__generics_8py_source_l00107}{create\+\_\+generic\+\_\+submodel()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a58fb0be9dd993d6b0c1659091ca30716}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!\_late\_cache\_key@{\_late\_cache\_key}}
\index{\_late\_cache\_key@{\_late\_cache\_key}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{\_late\_cache\_key()}{\_late\_cache\_key()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a58fb0be9dd993d6b0c1659091ca30716} 
 \mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_af66dce654d9513143523a13ddec1ff64}{Generic\+Types\+Cache\+Key}} pydantic.\+\_\+internal.\+\_\+generics.\+\_\+late\+\_\+cache\+\_\+key (\begin{DoxyParamCaption}\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}}]{origin}{, }\item[{tuple\mbox{[}Any, ...\mbox{]}}]{args}{, }\item[{Any}]{typevar\+\_\+values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}This is intended for use later in the process of creating a new type, when we have more information
about the exact args that will be passed. If it turns out that a different set of inputs to
__class_getitem__ resulted in the same inputs to the generic type creation process, we can still
return the cached type, and update the cache with the _early_cache_key as well.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00534}{534}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00501}{\+\_\+union\+\_\+orderings\+\_\+key()}}.



Referenciado por \mbox{\hyperlink{__generics_8py_source_l00464}{get\+\_\+cached\+\_\+generic\+\_\+type\+\_\+late()}} y \mbox{\hyperlink{__generics_8py_source_l00484}{set\+\_\+cached\+\_\+generic\+\_\+type()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_ad1b2be56fbba991bdca0c593c464a6c2}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!\_union\_orderings\_key@{\_union\_orderings\_key}}
\index{\_union\_orderings\_key@{\_union\_orderings\_key}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{\_union\_orderings\_key()}{\_union\_orderings\_key()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_ad1b2be56fbba991bdca0c593c464a6c2} 
 Any pydantic.\+\_\+internal.\+\_\+generics.\+\_\+union\+\_\+orderings\+\_\+key (\begin{DoxyParamCaption}\item[{Any}]{typevar\+\_\+values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}This is intended to help differentiate between Union types with the same arguments in different order.

Thanks to caching internal to the `typing` module, it is not possible to distinguish between
List[Union[int, float]] and List[Union[float, int]] (and similarly for other "parent" origins besides List)
because `typing` considers Union[int, float] to be equal to Union[float, int].

However, you _can_ distinguish between (top-level) Union[int, float] vs. Union[float, int].
Because we parse items as the first Union type that is successful, we get slightly more consistent behavior
if we make an effort to distinguish the ordering of items in a union. It would be best if we could _always_
get the exact-correct order of items in the union, but that would require a change to the `typing` module itself.
(See https://github.com/python/cpython/issues/86483 for reference.)
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00501}{501}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00501}{\+\_\+union\+\_\+orderings\+\_\+key()}}, \mbox{\hyperlink{__generics_8py_source_l00196}{get\+\_\+args()}} y \mbox{\hyperlink{micro__gestion__objetos_2venv_2_lib_2site-packages_2typing__extensions_8py_source_l01577}{typing\+\_\+extensions.\+get\+\_\+origin}}.



Referenciado por \mbox{\hyperlink{__generics_8py_source_l00522}{\+\_\+early\+\_\+cache\+\_\+key()}}, \mbox{\hyperlink{__generics_8py_source_l00534}{\+\_\+late\+\_\+cache\+\_\+key()}} y \mbox{\hyperlink{__generics_8py_source_l00501}{\+\_\+union\+\_\+orderings\+\_\+key()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_afcded858103d896453101e13b29d2a9b}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!create\_generic\_submodel@{create\_generic\_submodel}}
\index{create\_generic\_submodel@{create\_generic\_submodel}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{create\_generic\_submodel()}{create\_generic\_submodel()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_afcded858103d896453101e13b29d2a9b} 
 type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} pydantic.\+\_\+internal.\+\_\+generics.\+create\+\_\+generic\+\_\+submodel (\begin{DoxyParamCaption}\item[{str}]{model\+\_\+name}{, }\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}}]{origin}{, }\item[{tuple\mbox{[}Any, ...\mbox{]}}]{args}{, }\item[{tuple\mbox{[}Any, ...\mbox{]} }]{params}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Dynamically create a submodel of a provided (generic) BaseModel.

This is used when producing concrete parametrizations of generic models. This function
only *creates* the new subclass; the schema/validators/serialization must be updated to
reflect a concrete parametrization elsewhere.

Args:
    model_name: The name of the newly created model.
    origin: The base class for the new model to inherit from.
    args: A tuple of generic metadata arguments.
    params: A tuple of generic metadata parameters.

Returns:
    The created submodel.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00105}{105}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00152}{\+\_\+get\+\_\+caller\+\_\+frame\+\_\+info()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a05b120c91cf4df0a83a1cea779288b53}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!generic\_recursion\_self\_type@{generic\_recursion\_self\_type}}
\index{generic\_recursion\_self\_type@{generic\_recursion\_self\_type}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{generic\_recursion\_self\_type()}{generic\_recursion\_self\_type()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a05b120c91cf4df0a83a1cea779288b53} 
 Iterator\mbox{[}\mbox{\hyperlink{classpydantic_1_1__internal_1_1__forward__ref_1_1_pydantic_recursive_ref}{Pydantic\+Recursive\+Ref}} \texorpdfstring{$\vert$}{|} None\mbox{]} pydantic.\+\_\+internal.\+\_\+generics.\+generic\+\_\+recursion\+\_\+self\+\_\+type (\begin{DoxyParamCaption}\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}}]{origin}{, }\item[{tuple\mbox{[}Any, ...\mbox{]} }]{args}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}This contextmanager should be placed around the recursive calls used to build a generic type,
and accept as arguments the generic origin type and the type arguments being passed to it.

If the same origin and arguments are observed twice, it implies that a self-reference placeholder
can be used while building the core schema, and will produce a schema_ref that will be valid in the
final parent schema.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00399}{399}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a29a07a03dba4ccf370007eb6718cd7b9}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!get\_args@{get\_args}}
\index{get\_args@{get\_args}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{get\_args()}{get\_args()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a29a07a03dba4ccf370007eb6718cd7b9} 
 Any pydantic.\+\_\+internal.\+\_\+generics.\+get\+\_\+args (\begin{DoxyParamCaption}\item[{Any}]{v}{}\end{DoxyParamCaption})}



Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00196}{196}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{micro__gestion__objetos_2venv_2_lib_2site-packages_2typing__extensions_8py_source_l01578}{typing\+\_\+extensions.\+get\+\_\+args}}.



Referenciado por \mbox{\hyperlink{__generics_8py_source_l00501}{\+\_\+union\+\_\+orderings\+\_\+key()}}, \mbox{\hyperlink{__generics_8py_source_l00177}{iter\+\_\+contained\+\_\+typevars()}} y \mbox{\hyperlink{__generics_8py_source_l00245}{replace\+\_\+types()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a3c9314192feecb986c1a784369b212fa}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!get\_cached\_generic\_type\_early@{get\_cached\_generic\_type\_early}}
\index{get\_cached\_generic\_type\_early@{get\_cached\_generic\_type\_early}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{get\_cached\_generic\_type\_early()}{get\_cached\_generic\_type\_early()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a3c9314192feecb986c1a784369b212fa} 
 type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} \texorpdfstring{$\vert$}{|} None pydantic.\+\_\+internal.\+\_\+generics.\+get\+\_\+cached\+\_\+generic\+\_\+type\+\_\+early (\begin{DoxyParamCaption}\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}}]{parent}{, }\item[{Any}]{typevar\+\_\+values}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}The use of a two-stage cache lookup approach was necessary to have the highest performance possible for
repeated calls to `__class_getitem__` on generic types (which may happen in tighter loops during runtime),
while still ensuring that certain alternative parametrizations ultimately resolve to the same type.

As a concrete example, this approach was necessary to make Model[List[T]][int] equal to Model[List[int]].
The approach could be modified to not use two different cache keys at different points, but the
_early_cache_key is optimized to be as quick to compute as possible (for repeated-access speed), and the
_late_cache_key is optimized to be as "correct" as possible, so that two types that will ultimately be the
same after resolving the type arguments will always produce cache hits.

If we wanted to move to only using a single cache key per type, we would either need to always use the
slower/more computationally intensive logic associated with _late_cache_key, or would need to accept
that Model[List[T]][int] is a different type than Model[List[T]][int]. Because we rely on subclass relationships
during validation, I think it is worthwhile to ensure that types that are functionally equivalent are actually
equal.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00438}{438}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00522}{\+\_\+early\+\_\+cache\+\_\+key()}} y \mbox{\hyperlink{__generics_8py_source_l00058}{Generic\+Types\+Cache}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a1c055e35886a98db1334e04fc60f8be0}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!get\_cached\_generic\_type\_late@{get\_cached\_generic\_type\_late}}
\index{get\_cached\_generic\_type\_late@{get\_cached\_generic\_type\_late}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{get\_cached\_generic\_type\_late()}{get\_cached\_generic\_type\_late()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a1c055e35886a98db1334e04fc60f8be0} 
 type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} \texorpdfstring{$\vert$}{|} None pydantic.\+\_\+internal.\+\_\+generics.\+get\+\_\+cached\+\_\+generic\+\_\+type\+\_\+late (\begin{DoxyParamCaption}\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}}]{parent}{, }\item[{Any}]{typevar\+\_\+values}{, }\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}}]{origin}{, }\item[{tuple\mbox{[}Any, ...\mbox{]} }]{args}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}See the docstring of `get_cached_generic_type_early` for more information about the two-stage cache lookup.\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00462}{462}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00534}{\+\_\+late\+\_\+cache\+\_\+key()}}, \mbox{\hyperlink{__generics_8py_source_l00058}{Generic\+Types\+Cache}} y \mbox{\hyperlink{__generics_8py_source_l00484}{set\+\_\+cached\+\_\+generic\+\_\+type()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_af8dab9794ade8386bed3975ec7a1c3f8}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!get\_model\_typevars\_map@{get\_model\_typevars\_map}}
\index{get\_model\_typevars\_map@{get\_model\_typevars\_map}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{get\_model\_typevars\_map()}{get\_model\_typevars\_map()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_af8dab9794ade8386bed3975ec7a1c3f8} 
 dict\mbox{[}Type\+Var, Any\mbox{]} pydantic.\+\_\+internal.\+\_\+generics.\+get\+\_\+model\+\_\+typevars\+\_\+map (\begin{DoxyParamCaption}\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}}]{cls}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Package a generic BaseModel's typevars and concrete parametrization (if present) into a dictionary compatible
with the `replace_types` function.

Since BaseModel.__class_getitem__ does not produce a typing._GenericAlias, and the BaseModel generic info is
stored in the __pydantic_generic_metadata__ attribute, we need special handling here.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00227}{227}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00177}{iter\+\_\+contained\+\_\+typevars()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a71145b763a2bc45e77b2f646d9d365b5}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!get\_origin@{get\_origin}}
\index{get\_origin@{get\_origin}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{get\_origin()}{get\_origin()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a71145b763a2bc45e77b2f646d9d365b5} 
 Any pydantic.\+\_\+internal.\+\_\+generics.\+get\+\_\+origin (\begin{DoxyParamCaption}\item[{Any}]{v}{}\end{DoxyParamCaption})}



Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00203}{203}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{micro__gestion__objetos_2venv_2_lib_2site-packages_2typing__extensions_8py_source_l01577}{typing\+\_\+extensions.\+get\+\_\+origin}}.



Referenciado por \mbox{\hyperlink{__generics_8py_source_l00210}{get\+\_\+standard\+\_\+typevars\+\_\+map()}} y \mbox{\hyperlink{__generics_8py_source_l00245}{replace\+\_\+types()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_ae5f63b9cae8e839cd0f0237583dd02c8}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!get\_standard\_typevars\_map@{get\_standard\_typevars\_map}}
\index{get\_standard\_typevars\_map@{get\_standard\_typevars\_map}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{get\_standard\_typevars\_map()}{get\_standard\_typevars\_map()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_ae5f63b9cae8e839cd0f0237583dd02c8} 
 dict\mbox{[}Type\+Var, Any\mbox{]} \texorpdfstring{$\vert$}{|} None pydantic.\+\_\+internal.\+\_\+generics.\+get\+\_\+standard\+\_\+typevars\+\_\+map (\begin{DoxyParamCaption}\item[{Any}]{cls}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Package a generic type's typevars and parametrization (if present) into a dictionary compatible with the
`replace_types` function. Specifically, this works with standard typing generics and typing._GenericAlias.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00210}{210}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00203}{get\+\_\+origin()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a91e72b4bc6889cef434bb6ffd83d61bc}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!iter\_contained\_typevars@{iter\_contained\_typevars}}
\index{iter\_contained\_typevars@{iter\_contained\_typevars}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{iter\_contained\_typevars()}{iter\_contained\_typevars()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a91e72b4bc6889cef434bb6ffd83d61bc} 
 Iterator\mbox{[}Type\+Var\mbox{]} pydantic.\+\_\+internal.\+\_\+generics.\+iter\+\_\+contained\+\_\+typevars (\begin{DoxyParamCaption}\item[{Any}]{v}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Recursively iterate through all subtypes and type args of `v` and yield any typevars that are found.

This is inspired as an alternative to directly accessing the `__parameters__` attribute of a GenericAlias,
since __parameters__ of (nested) generic BaseModel subclasses won't show up in that list.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00177}{177}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00196}{get\+\_\+args()}} y \mbox{\hyperlink{__generics_8py_source_l00177}{iter\+\_\+contained\+\_\+typevars()}}.



Referenciado por \mbox{\hyperlink{__generics_8py_source_l00227}{get\+\_\+model\+\_\+typevars\+\_\+map()}} y \mbox{\hyperlink{__generics_8py_source_l00177}{iter\+\_\+contained\+\_\+typevars()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a988383c2fcc5e45381e7a3246650d212}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!map\_generic\_model\_arguments@{map\_generic\_model\_arguments}}
\index{map\_generic\_model\_arguments@{map\_generic\_model\_arguments}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{map\_generic\_model\_arguments()}{map\_generic\_model\_arguments()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a988383c2fcc5e45381e7a3246650d212} 
 dict\mbox{[}Type\+Var, Any\mbox{]} pydantic.\+\_\+internal.\+\_\+generics.\+map\+\_\+generic\+\_\+model\+\_\+arguments (\begin{DoxyParamCaption}\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}}]{cls}{, }\item[{tuple\mbox{[}Any, ...\mbox{]}}]{args}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a mapping between the parameters of a generic model and the provided arguments during parameterization.

Raises:
    TypeError: If the number of arguments does not match the parameters (i.e. if providing too few or too many arguments).

Example:
    ```python {test="skip" lint="skip"}
    class Model[T, U, V = int](BaseModel): ...

    map_generic_model_arguments(Model, (str, bytes))
    #> {T: str, U: bytes, V: int}

    map_generic_model_arguments(Model, (str,))
    #> TypeError: Too few arguments for <class '__main__.Model'>; actual 1, expected at least 2

    map_generic_model_arguments(Model, (str, bytes, int, complex))
    #> TypeError: Too many arguments for <class '__main__.Model'>; actual 4, expected 3
    ```

Note:
    This function is analogous to the private `typing._check_generic_specialization` function.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00342}{342}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00245}{replace\+\_\+types()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a58e6abceadaad8d39b24555f71afe7d9}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!recursively\_defined\_type\_refs@{recursively\_defined\_type\_refs}}
\index{recursively\_defined\_type\_refs@{recursively\_defined\_type\_refs}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{recursively\_defined\_type\_refs()}{recursively\_defined\_type\_refs()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a58e6abceadaad8d39b24555f71afe7d9} 
 set\mbox{[}str\mbox{]} pydantic.\+\_\+internal.\+\_\+generics.\+recursively\+\_\+defined\+\_\+type\+\_\+refs (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00430}{430}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_abf393e8a431474b872c9096a8e99fadd}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!replace\_types@{replace\_types}}
\index{replace\_types@{replace\_types}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{replace\_types()}{replace\_types()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_abf393e8a431474b872c9096a8e99fadd} 
 Any pydantic.\+\_\+internal.\+\_\+generics.\+replace\+\_\+types (\begin{DoxyParamCaption}\item[{Any}]{type\+\_\+}{, }\item[{Mapping\mbox{[}Type\+Var, Any\mbox{]} \texorpdfstring{$\vert$}{|} None}]{type\+\_\+map}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return type with all occurrences of `type_map` keys recursively replaced with their values.

Args:
    type_: The class or generic alias.
    type_map: Mapping from `TypeVar` instance to concrete types.

Returns:
    A new type representing the basic structure of `type_` with all
    `typevar_map` keys recursively replaced.

Example:
    ```python
    from typing import Union

    from pydantic._internal._generics import replace_types

    replace_types(tuple[str, Union[list[str], float]], {str: int})
    #> tuple[int, Union[list[int], float]]
    ```
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00245}{245}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00196}{get\+\_\+args()}}, \mbox{\hyperlink{__generics_8py_source_l00203}{get\+\_\+origin()}} y \mbox{\hyperlink{__generics_8py_source_l00245}{replace\+\_\+types()}}.



Referenciado por \mbox{\hyperlink{__generics_8py_source_l00342}{map\+\_\+generic\+\_\+model\+\_\+arguments()}} y \mbox{\hyperlink{__generics_8py_source_l00245}{replace\+\_\+types()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_ac46c5b5c5c2d0a221f8cda82b25ae9c0}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!set\_cached\_generic\_type@{set\_cached\_generic\_type}}
\index{set\_cached\_generic\_type@{set\_cached\_generic\_type}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{set\_cached\_generic\_type()}{set\_cached\_generic\_type()}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_ac46c5b5c5c2d0a221f8cda82b25ae9c0} 
 None pydantic.\+\_\+internal.\+\_\+generics.\+set\+\_\+cached\+\_\+generic\+\_\+type (\begin{DoxyParamCaption}\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}}]{parent}{, }\item[{tuple\mbox{[}Any, ...\mbox{]}}]{typevar\+\_\+values}{, }\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}}]{type\+\_\+}{, }\item[{type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]} \texorpdfstring{$\vert$}{|} None }]{origin}{ = {\ttfamily None}, }\item[{tuple\mbox{[}Any, ...\mbox{]} \texorpdfstring{$\vert$}{|} None }]{args}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}See the docstring of `get_cached_generic_type_early` for more information about why items are cached with
two different keys.
\end{DoxyVerb}
 

Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00478}{478}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Hace referencia a \mbox{\hyperlink{__generics_8py_source_l00522}{\+\_\+early\+\_\+cache\+\_\+key()}}, \mbox{\hyperlink{__generics_8py_source_l00534}{\+\_\+late\+\_\+cache\+\_\+key()}} y \mbox{\hyperlink{__generics_8py_source_l00058}{Generic\+Types\+Cache}}.



Referenciado por \mbox{\hyperlink{__generics_8py_source_l00464}{get\+\_\+cached\+\_\+generic\+\_\+type\+\_\+late()}}.



\label{doc-var-members}
\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_doc-var-members}
\doxysubsection{Documentación de variables}
\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a852f427cbedb8cfd7cf488f2ffef9c18}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!\_generic\_recursion\_cache@{\_generic\_recursion\_cache}}
\index{\_generic\_recursion\_cache@{\_generic\_recursion\_cache}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{\_generic\_recursion\_cache}{\_generic\_recursion\_cache}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a852f427cbedb8cfd7cf488f2ffef9c18} 
Context\+Var pydantic.\+\_\+internal.\+\_\+generics.\+\_\+generic\+\_\+recursion\+\_\+cache = Context\+Var(\textquotesingle{}\+\_\+generic\+\_\+recursion\+\_\+cache\textquotesingle{}, default=None)\hspace{0.3cm}{\ttfamily [protected]}}



Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00395}{395}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_ab0a4726777265f7ae662e5519a732e5b}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!\_LIMITED\_DICT\_SIZE@{\_LIMITED\_DICT\_SIZE}}
\index{\_LIMITED\_DICT\_SIZE@{\_LIMITED\_DICT\_SIZE}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{\_LIMITED\_DICT\_SIZE}{\_LIMITED\_DICT\_SIZE}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_ab0a4726777265f7ae662e5519a732e5b} 
int pydantic.\+\_\+internal.\+\_\+generics.\+\_\+\+LIMITED\+\_\+\+DICT\+\_\+\+SIZE = 100\hspace{0.3cm}{\ttfamily [protected]}}



Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00039}{39}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_ac482f3da5f4edd52b0b458c5a729c253}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!DictValues@{DictValues}}
\index{DictValues@{DictValues}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{DictValues}{DictValues}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_ac482f3da5f4edd52b0b458c5a729c253} 
dict pydantic.\+\_\+internal.\+\_\+generics.\+Dict\+Values = \{\}.values().\+\_\+\+\_\+class\+\_\+\+\_\+}



Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00174}{174}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a39a759bcb29ba97f166450d257693259}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!GenericTypesCache@{GenericTypesCache}}
\index{GenericTypesCache@{GenericTypesCache}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{GenericTypesCache}{GenericTypesCache}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a39a759bcb29ba97f166450d257693259} 
pydantic.\+\_\+internal.\+\_\+generics.\+Generic\+Types\+Cache = Weak\+Value\+Dictionary\mbox{[}\mbox{\hyperlink{namespacepydantic_1_1__internal_1_1__generics_af66dce654d9513143523a13ddec1ff64}{Generic\+Types\+Cache\+Key}}, \textquotesingle{}type\mbox{[}\mbox{\hyperlink{classpydantic_1_1main_1_1_base_model}{Base\+Model}}\mbox{]}\textquotesingle{}\mbox{]}}



Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00058}{58}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.



Referenciado por \mbox{\hyperlink{__generics_8py_source_l00438}{get\+\_\+cached\+\_\+generic\+\_\+type\+\_\+early()}}, \mbox{\hyperlink{__generics_8py_source_l00464}{get\+\_\+cached\+\_\+generic\+\_\+type\+\_\+late()}} y \mbox{\hyperlink{__generics_8py_source_l00484}{set\+\_\+cached\+\_\+generic\+\_\+type()}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_af66dce654d9513143523a13ddec1ff64}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!GenericTypesCacheKey@{GenericTypesCacheKey}}
\index{GenericTypesCacheKey@{GenericTypesCacheKey}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{GenericTypesCacheKey}{GenericTypesCacheKey}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_af66dce654d9513143523a13ddec1ff64} 
pydantic.\+\_\+internal.\+\_\+generics.\+Generic\+Types\+Cache\+Key = tuple\mbox{[}Any, Any, tuple\mbox{[}Any, ...\mbox{]}\mbox{]}}



Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00029}{29}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a9105fc49941fc60b0585824ef933bd48}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!KT@{KT}}
\index{KT@{KT}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{KT}{KT}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a9105fc49941fc60b0585824ef933bd48} 
pydantic.\+\_\+internal.\+\_\+generics.\+KT = Type\+Var(\textquotesingle{}KT\textquotesingle{})}



Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00037}{37}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.

\Hypertarget{namespacepydantic_1_1__internal_1_1__generics_a041e256fadbac3133f8d1c4dab1df1f2}\index{pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}!VT@{VT}}
\index{VT@{VT}!pydantic.\_internal.\_generics@{pydantic.\_internal.\_generics}}
\doxysubsubsection{\texorpdfstring{VT}{VT}}
{\footnotesize\ttfamily \label{namespacepydantic_1_1__internal_1_1__generics_a041e256fadbac3133f8d1c4dab1df1f2} 
pydantic.\+\_\+internal.\+\_\+generics.\+VT = Type\+Var(\textquotesingle{}VT\textquotesingle{})}



Definición en la línea \mbox{\hyperlink{__generics_8py_source_l00038}{38}} del archivo \mbox{\hyperlink{__generics_8py_source}{\+\_\+generics.\+py}}.

